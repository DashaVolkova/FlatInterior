/*! H5F
* https://github.com/ryanseddon/H5F/
* Copyright (c) Ryan Seddon | Licensed MIT */

(function (root, factory) {
    if (typeof define === 'function' && define.amd) {
        // AMD. Register as an anonymous module.
        define(factory);
    } else if (typeof module === 'object' && module.exports)  {
        // CommonJS
        module.exports = factory();
    } else {
        // Browser globals
        root.H5F = factory();
    }
}(this, function () {

    var d = document,
        field = d.createElement("input"),
        emailPatt = /^[a-zA-Z0-9.!#$%&'*+-\/=?\^_`{|}~-]+@[a-zA-Z0-9-]+(?:\.[a-zA-Z0-9-]+)*$/,
        urlPatt = /[a-z][\-\.+a-z]*:\/\//i,
        nodes = /^(input|select|textarea)$/i,
        isSubmit, bypassSubmit, usrPatt, curEvt, args,
        // Methods
        setup, validation, validity, checkField, bypassChecks, checkValidity, setCustomValidity, support, pattern, placeholder, range, required, valueMissing, listen, unlisten, preventActions, getTarget, addClass, removeClass, isHostMethod, isSiblingChecked;

    setup = function(form, settings) {
        var isCollection = !form.nodeType || false;

        var opts = {
            validClass : "valid",
            invalidClass : "error",
            requiredClass : "required",
            placeholderClass : "placeholder",
            onSubmit : Function.prototype,
            onInvalid : Function.prototype
        };

        if(typeof settings === "object") {
            for (var i in opts) {
                if(typeof settings[i] === "undefined") { settings[i] = opts[i]; }
            }
        }

        args = settings || opts;

        if(isCollection) {
            for(var k=0,len=form.length;k<len;k++) {
                validation(form[k]);
            }
        } else {
            validation(form);
        }
    };

    validation = function(form) {
        var f = form.elements,
            flen = f.length,
            isRequired,
            noValidate = !!(form.attributes["novalidate"]);

        listen(form,"invalid",checkField,true);
        listen(form,"blur",checkField,true);
        listen(form,"input",checkField,true);
        listen(form,"keyup",checkField,true);
        listen(form,"focus",checkField,true);
        listen(form,"change",checkField,true);
        listen(form,"click",bypassChecks,true);

        listen(form,"submit",function(e){
            isSubmit = true;
            if(!bypassSubmit && !noValidate && !form.checkValidity()) {
                preventActions(e);
                return;
            }
            args.onSubmit.call(form, e);
        },false);

        if(!support()) {
            form.checkValidity = function() { return checkValidity(form); };

            while(flen--) {
                isRequired = !!(f[flen].attributes["required"]);
                // Firefox includes fieldsets inside elements nodelist so we filter it out.
                if(f[flen].nodeName.toLowerCase() !== "fieldset") {
                    validity(f[flen]); // Add validity object to field
                }
            }
        }
    };
    validity = function(el) {
        var elem = el,
            missing = valueMissing(elem),
            attrs = {
                type: elem.getAttribute("type"),
                pattern: elem.getAttribute("pattern"),
                placeholder: elem.getAttribute("placeholder")
            },
            isType = /^(email|url)$/i,
            evt = /^(input|keyup)$/i,
            fType = ((isType.test(attrs.type)) ? attrs.type : ((attrs.pattern) ? attrs.pattern : false)),
            patt = pattern(elem,fType),
            step = range(elem,"step"),
            min = range(elem,"min"),
            max = range(elem,"max"),
            customError = !( elem.validationMessage === "" || elem.validationMessage === undefined );

        elem.checkValidity = function() { return checkValidity.call(this,elem); };
        elem.setCustomValidity = function(msg) { setCustomValidity.call(elem,msg); };

        elem.validity = {
            valueMissing: missing,
            patternMismatch: patt,
            rangeUnderflow: min,
            rangeOverflow: max,
            stepMismatch: step,
            customError: customError,
            valid: (!missing && !patt && !step && !min && !max && !customError)
        };

        if(attrs.placeholder && !evt.test(curEvt)) { placeholder(elem); }
    };
    checkField = function(e) {
        var el = getTarget(e) || e, // checkValidity method passes element not event
            events = /^(input|keyup|focusin|focus|change)$/i,
            ignoredTypes = /^(submit|image|button|reset)$/i,
            specialTypes = /^(checkbox|radio)$/i,
            checkForm = true;

        if(nodes.test(el.nodeName) && !(ignoredTypes.test(el.type) || ignoredTypes.test(el.nodeName))) {
            curEvt = e.type;

            if(!support()) {
                validity(el);
            }

            if(el.validity.valid && (el.value !== "" || specialTypes.test(el.type)) || (el.value !== el.getAttribute("placeholder") && el.validity.valid)) {
                removeClass(el,[args.invalidClass,args.requiredClass]);
                addClass(el,args.validClass);
            } else if(!events.test(curEvt)) {
                if(el.validity.valueMissing) {
                    removeClass(el,[args.invalidClass,args.validClass]);
                    addClass(el,args.requiredClass);
                } else if(!el.validity.valid) {
                    removeClass(el,[args.validClass,args.requiredClass]);
                    addClass(el,args.invalidClass);
                }
            } else if(el.validity.valueMissing) {
                removeClass(el,[args.requiredClass,args.invalidClass,args.validClass]);
            }
            if(curEvt === "input" && checkForm) {
                // If input is triggered remove the keyup event
                unlisten(el.form,"keyup",checkField,true);
                checkForm = false;
            }
        }
    };
    checkValidity = function(el) {
        var f, ff, isDisabled, isRequired, hasPattern, invalid = false;

        if(el.nodeName.toLowerCase() === "form") {
            f = el.elements;

            for(var i = 0,len = f.length;i < len;i++) {
                ff = f[i];

                isDisabled = !!(ff.attributes["disabled"]);
                isRequired = !!(ff.attributes["required"]);
                hasPattern = !!(ff.attributes["pattern"]);

                if(ff.nodeName.toLowerCase() !== "fieldset" && !isDisabled && (isRequired || hasPattern && isRequired)) {
                    checkField(ff);
                    if(!ff.validity.valid && !invalid) {
                        if(isSubmit) { // If it's not a submit event the field shouldn't be focused
                            ff.focus();
                        }
                        invalid = true;
                        args.onInvalid.call(el, ff);
                    }
                }
            }
            return !invalid;
        } else {
            checkField(el);
            return el.validity.valid;
        }
    };
    setCustomValidity = function(msg) {
        var el = this;

        el.validationMessage = msg;
    };

    bypassChecks = function(e) {
        // handle formnovalidate attribute
        var el = getTarget(e);

        if(el.attributes["formnovalidate"] && el.type === "submit") {
            bypassSubmit = true;
        }
    };

    support = function() {
        return (isHostMethod(field,"validity") && isHostMethod(field,"checkValidity"));
    };

    // Create helper methods to emulate attributes in older browsers
    pattern = function(el, type) {
        if(type === "email") {
            return !emailPatt.test(el.value);
        } else if(type === "url") {
            return !urlPatt.test(el.value);
        } else if(!type) {
            return false;
        } else {
            var placeholder = el.getAttribute("placeholder"),
                val = el.value;

            usrPatt = new RegExp('^(?:' + type + ')$');

            if(val === placeholder) {
                return false;
            } else if(val === "") {
                return false;
            } else {
                return !usrPatt.test(el.value);
            }
        }
    };
    placeholder = function(el) {
        var attrs = { placeholder: el.getAttribute("placeholder") },
            focus = /^(focus|focusin|submit)$/i,
            node = /^(input|textarea)$/i,
            ignoredType = /^password$/i,
            isNative = !!("placeholder" in field);

        if(!isNative && node.test(el.nodeName) && !ignoredType.test(el.type)) {
            if(el.value === "" && !focus.test(curEvt)) {
                el.value = attrs.placeholder;
                listen(el.form,'submit', function () {
                  curEvt = 'submit';
                  placeholder(el);
                }, true);
                addClass(el,args.placeholderClass);
            } else if(el.value === attrs.placeholder && focus.test(curEvt)) {
                el.value = "";
                removeClass(el,args.placeholderClass);
            }
        }
    };
    range = function(el, type) {
        // Emulate min, max and step
        var min = parseInt(el.getAttribute("min"),10) || 0,
            max = parseInt(el.getAttribute("max"),10) || false,
            step = parseInt(el.getAttribute("step"),10) || 1,
            val = parseInt(el.value,10),
            mismatch = (val-min)%step;

        if(!valueMissing(el) && !isNaN(val)) {
            if(type === "step") {
                return (el.getAttribute("step")) ? (mismatch !== 0) : false;
            } else if(type === "min") {
                return (el.getAttribute("min")) ? (val < min) : false;
            } else if(type === "max") {
                return (el.getAttribute("max")) ? (val > max) : false;
            }
        } else if(el.getAttribute("type") === "number") {
            return true;
        } else {
            return false;
        }
    };
    required = function(el) {
        var required = !!(el.attributes["required"]);

        return (required) ? valueMissing(el) : false;
    };
    valueMissing = function(el) {
        var placeholder = el.getAttribute("placeholder"),
            specialTypes = /^(checkbox|radio)$/i,
            isRequired = !!(el.attributes["required"]);
        return !!(isRequired && (el.value === "" || el.value === placeholder || (specialTypes.test(el.type) && !isSiblingChecked(el))));
    };

    /* Util methods */
    listen = function (node,type,fn,capture) {
        if(isHostMethod(window,"addEventListener")) {
            /* FF & Other Browsers */
            node.addEventListener( type, fn, capture );
        } else if(isHostMethod(window,"attachEvent") && typeof window.event !== "undefined") {
            /* Internet Explorer way */
            if(type === "blur") {
                type = "focusout";
            } else if(type === "focus") {
                type = "focusin";
            }
            node.attachEvent( "on" + type, fn );
        }
    };
    unlisten = function (node,type,fn,capture) {
        if(isHostMethod(window,"removeEventListener")) {
            /* FF & Other Browsers */
            node.removeEventListener( type, fn, capture );
        } else if(isHostMethod(window,"detachEvent") && typeof window.event !== "undefined") {
            /* Internet Explorer way */
            node.detachEvent( "on" + type, fn );
        }
    };
    preventActions = function (evt) {
        evt = evt || window.event;

        if(evt.stopPropagation && evt.preventDefault) {
            evt.stopPropagation();
            evt.preventDefault();
        } else {
            evt.cancelBubble = true;
            evt.returnValue = false;
        }
    };
    getTarget = function (evt) {
        evt = evt || window.event;
        return evt.target || evt.srcElement;
    };
    addClass = function (e,c) {
        var re;
        if (!e.className) {
            e.className = c;
        }
        else {
            re = new RegExp('(^|\\s)' + c + '(\\s|$)');
            if (!re.test(e.className)) { e.className += ' ' + c; }
        }
    };
    removeClass = function (e,c) {
        var re, m, arr = (typeof c === "object") ? c.length : 1, len = arr;
        if (e.className) {
            if (e.className === c) {
                e.className = '';
            } else {
                while(arr--) {
                    re = new RegExp('(^|\\s)' + ((len > 1) ? c[arr] : c) + '(\\s|$)');
                    m = e.className.match(re);
                    if (m && m.length === 3) { e.className = e.className.replace(re, (m[1] && m[2])?' ':''); }
                }
            }
        }
    };
    isHostMethod = function(o, m) {
        var t = typeof o[m], reFeaturedMethod = new RegExp('^function|object$', 'i');
        return !!((reFeaturedMethod.test(t) && o[m]) || t === 'unknown');
    };
    /* Checking if one of the radio siblings is checked */
    isSiblingChecked = function(el) {
        var siblings = document.getElementsByName(el.name);
        for(var i=0; i<siblings.length; i++){
            if(siblings[i].checked){
                return true;
            }
        }
        return false;
    };

    // Since all methods are only used internally no need to expose globally
    return {
        setup: setup
    };

}));
;
/**
 * @preserve FastClick: polyfill to remove click delays on browsers with touch UIs.
 *
 * @version 0.6.11
 * @codingstandard ftlabs-jsv2
 * @copyright The Financial Times Limited [All Rights Reserved]
 * @license MIT License (see LICENSE.txt)
 */

/*jslint browser:true, node:true*/
/*global define, Event, Node*/


/**
 * Instantiate fast-clicking listeners on the specificed layer.
 *
 * @constructor
 * @param {Element} layer The layer to listen on
 */
function FastClick(layer) {
	'use strict';
	var oldOnClick, self = this;


	/**
	 * Whether a click is currently being tracked.
	 *
	 * @type boolean
	 */
	this.trackingClick = false;


	/**
	 * Timestamp for when when click tracking started.
	 *
	 * @type number
	 */
	this.trackingClickStart = 0;


	/**
	 * The element being tracked for a click.
	 *
	 * @type EventTarget
	 */
	this.targetElement = null;


	/**
	 * X-coordinate of touch start event.
	 *
	 * @type number
	 */
	this.touchStartX = 0;


	/**
	 * Y-coordinate of touch start event.
	 *
	 * @type number
	 */
	this.touchStartY = 0;


	/**
	 * ID of the last touch, retrieved from Touch.identifier.
	 *
	 * @type number
	 */
	this.lastTouchIdentifier = 0;


	/**
	 * Touchmove boundary, beyond which a click will be cancelled.
	 *
	 * @type number
	 */
	this.touchBoundary = 10;


	/**
	 * The FastClick layer.
	 *
	 * @type Element
	 */
	this.layer = layer;

	if (!layer || !layer.nodeType) {
		throw new TypeError('Layer must be a document node');
	}

	/** @type function() */
	this.onClick = function() { return FastClick.prototype.onClick.apply(self, arguments); };

	/** @type function() */
	this.onMouse = function() { return FastClick.prototype.onMouse.apply(self, arguments); };

	/** @type function() */
	this.onTouchStart = function() { return FastClick.prototype.onTouchStart.apply(self, arguments); };

	/** @type function() */
	this.onTouchMove = function() { return FastClick.prototype.onTouchMove.apply(self, arguments); };

	/** @type function() */
	this.onTouchEnd = function() { return FastClick.prototype.onTouchEnd.apply(self, arguments); };

	/** @type function() */
	this.onTouchCancel = function() { return FastClick.prototype.onTouchCancel.apply(self, arguments); };

	if (FastClick.notNeeded(layer)) {
		return;
	}

	// Set up event handlers as required
	if (this.deviceIsAndroid) {
		layer.addEventListener('mouseover', this.onMouse, true);
		layer.addEventListener('mousedown', this.onMouse, true);
		layer.addEventListener('mouseup', this.onMouse, true);
	}

	layer.addEventListener('click', this.onClick, true);
	layer.addEventListener('touchstart', this.onTouchStart, false);
	layer.addEventListener('touchmove', this.onTouchMove, false);
	layer.addEventListener('touchend', this.onTouchEnd, false);
	layer.addEventListener('touchcancel', this.onTouchCancel, false);

	// Hack is required for browsers that don't support Event#stopImmediatePropagation (e.g. Android 2)
	// which is how FastClick normally stops click events bubbling to callbacks registered on the FastClick
	// layer when they are cancelled.
	if (!Event.prototype.stopImmediatePropagation) {
		layer.removeEventListener = function(type, callback, capture) {
			var rmv = Node.prototype.removeEventListener;
			if (type === 'click') {
				rmv.call(layer, type, callback.hijacked || callback, capture);
			} else {
				rmv.call(layer, type, callback, capture);
			}
		};

		layer.addEventListener = function(type, callback, capture) {
			var adv = Node.prototype.addEventListener;
			if (type === 'click') {
				adv.call(layer, type, callback.hijacked || (callback.hijacked = function(event) {
					if (!event.propagationStopped) {
						callback(event);
					}
				}), capture);
			} else {
				adv.call(layer, type, callback, capture);
			}
		};
	}

	// If a handler is already declared in the element's onclick attribute, it will be fired before
	// FastClick's onClick handler. Fix this by pulling out the user-defined handler function and
	// adding it as listener.
	if (typeof layer.onclick === 'function') {

		// Android browser on at least 3.2 requires a new reference to the function in layer.onclick
		// - the old one won't work if passed to addEventListener directly.
		oldOnClick = layer.onclick;
		layer.addEventListener('click', function(event) {
			oldOnClick(event);
		}, false);
		layer.onclick = null;
	}
}


/**
 * Android requires exceptions.
 *
 * @type boolean
 */
FastClick.prototype.deviceIsAndroid = navigator.userAgent.indexOf('Android') > 0;


/**
 * iOS requires exceptions.
 *
 * @type boolean
 */
FastClick.prototype.deviceIsIOS = /iP(ad|hone|od)/.test(navigator.userAgent);


/**
 * iOS 4 requires an exception for select elements.
 *
 * @type boolean
 */
FastClick.prototype.deviceIsIOS4 = FastClick.prototype.deviceIsIOS && (/OS 4_\d(_\d)?/).test(navigator.userAgent);


/**
 * iOS 6.0(+?) requires the target element to be manually derived
 *
 * @type boolean
 */
FastClick.prototype.deviceIsIOSWithBadTarget = FastClick.prototype.deviceIsIOS && (/OS ([6-9]|\d{2})_\d/).test(navigator.userAgent);


/**
 * Determine whether a given element requires a native click.
 *
 * @param {EventTarget|Element} target Target DOM element
 * @returns {boolean} Returns true if the element needs a native click
 */
FastClick.prototype.needsClick = function(target) {
	'use strict';
	switch (target.nodeName.toLowerCase()) {

	// Don't send a synthetic click to disabled inputs (issue #62)
	case 'button':
	case 'select':
	case 'textarea':
		if (target.disabled) {
			return true;
		}

		break;
	case 'input':

		// File inputs need real clicks on iOS 6 due to a browser bug (issue #68)
		if ((this.deviceIsIOS && target.type === 'file') || target.disabled) {
			return true;
		}

		break;
	case 'label':
	case 'video':
		return true;
	}

	return (/\bneedsclick\b/).test(target.className);
};


/**
 * Determine whether a given element requires a call to focus to simulate click into element.
 *
 * @param {EventTarget|Element} target Target DOM element
 * @returns {boolean} Returns true if the element requires a call to focus to simulate native click.
 */
FastClick.prototype.needsFocus = function(target) {
	'use strict';
	switch (target.nodeName.toLowerCase()) {
	case 'textarea':
		return true;
	case 'select':
		return !this.deviceIsAndroid;
	case 'input':
		switch (target.type) {
		case 'button':
		case 'checkbox':
		case 'file':
		case 'image':
		case 'radio':
		case 'submit':
			return false;
		}

		// No point in attempting to focus disabled inputs
		return !target.disabled && !target.readOnly;
	default:
		return (/\bneedsfocus\b/).test(target.className);
	}
};


/**
 * Send a click event to the specified element.
 *
 * @param {EventTarget|Element} targetElement
 * @param {Event} event
 */
FastClick.prototype.sendClick = function(targetElement, event) {
	'use strict';
	var clickEvent, touch;

	// On some Android devices activeElement needs to be blurred otherwise the synthetic click will have no effect (#24)
	if (document.activeElement && document.activeElement !== targetElement) {
		document.activeElement.blur();
	}

	touch = event.changedTouches[0];

	// Synthesise a click event, with an extra attribute so it can be tracked
	clickEvent = document.createEvent('MouseEvents');
	clickEvent.initMouseEvent(this.determineEventType(targetElement), true, true, window, 1, touch.screenX, touch.screenY, touch.clientX, touch.clientY, false, false, false, false, 0, null);
	clickEvent.forwardedTouchEvent = true;
	targetElement.dispatchEvent(clickEvent);
};

FastClick.prototype.determineEventType = function(targetElement) {
	'use strict';

	//Issue #159: Android Chrome Select Box does not open with a synthetic click event
	if (this.deviceIsAndroid && targetElement.tagName.toLowerCase() === 'select') {
		return 'mousedown';
	}

	return 'click';
};


/**
 * @param {EventTarget|Element} targetElement
 */
FastClick.prototype.focus = function(targetElement) {
	'use strict';
	var length;

	// Issue #160: on iOS 7, some input elements (e.g. date datetime) throw a vague TypeError on setSelectionRange. These elements don't have an integer value for the selectionStart and selectionEnd properties, but unfortunately that can't be used for detection because accessing the properties also throws a TypeError. Just check the type instead. Filed as Apple bug #15122724.
	if (this.deviceIsIOS && targetElement.setSelectionRange && targetElement.type.indexOf('date') !== 0 && targetElement.type !== 'time') {
		length = targetElement.value.length;
		targetElement.setSelectionRange(length, length);
	} else {
		targetElement.focus();
	}
};


/**
 * Check whether the given target element is a child of a scrollable layer and if so, set a flag on it.
 *
 * @param {EventTarget|Element} targetElement
 */
FastClick.prototype.updateScrollParent = function(targetElement) {
	'use strict';
	var scrollParent, parentElement;

	scrollParent = targetElement.fastClickScrollParent;

	// Attempt to discover whether the target element is contained within a scrollable layer. Re-check if the
	// target element was moved to another parent.
	if (!scrollParent || !scrollParent.contains(targetElement)) {
		parentElement = targetElement;
		do {
			if (parentElement.scrollHeight > parentElement.offsetHeight) {
				scrollParent = parentElement;
				targetElement.fastClickScrollParent = parentElement;
				break;
			}

			parentElement = parentElement.parentElement;
		} while (parentElement);
	}

	// Always update the scroll top tracker if possible.
	if (scrollParent) {
		scrollParent.fastClickLastScrollTop = scrollParent.scrollTop;
	}
};


/**
 * @param {EventTarget} targetElement
 * @returns {Element|EventTarget}
 */
FastClick.prototype.getTargetElementFromEventTarget = function(eventTarget) {
	'use strict';

	// On some older browsers (notably Safari on iOS 4.1 - see issue #56) the event target may be a text node.
	if (eventTarget.nodeType === Node.TEXT_NODE) {
		return eventTarget.parentNode;
	}

	return eventTarget;
};


/**
 * On touch start, record the position and scroll offset.
 *
 * @param {Event} event
 * @returns {boolean}
 */
FastClick.prototype.onTouchStart = function(event) {
	'use strict';
	var targetElement, touch, selection;

	// Ignore multiple touches, otherwise pinch-to-zoom is prevented if both fingers are on the FastClick element (issue #111).
	if (event.targetTouches.length > 1) {
		return true;
	}

	targetElement = this.getTargetElementFromEventTarget(event.target);
	touch = event.targetTouches[0];

	if (this.deviceIsIOS) {

		// Only trusted events will deselect text on iOS (issue #49)
		selection = window.getSelection();
		if (selection.rangeCount && !selection.isCollapsed) {
			return true;
		}

		if (!this.deviceIsIOS4) {

			// Weird things happen on iOS when an alert or confirm dialog is opened from a click event callback (issue #23):
			// when the user next taps anywhere else on the page, new touchstart and touchend events are dispatched
			// with the same identifier as the touch event that previously triggered the click that triggered the alert.
			// Sadly, there is an issue on iOS 4 that causes some normal touch events to have the same identifier as an
			// immediately preceeding touch event (issue #52), so this fix is unavailable on that platform.
			if (touch.identifier === this.lastTouchIdentifier) {
				event.preventDefault();
				return false;
			}

			this.lastTouchIdentifier = touch.identifier;

			// If the target element is a child of a scrollable layer (using -webkit-overflow-scrolling: touch) and:
			// 1) the user does a fling scroll on the scrollable layer
			// 2) the user stops the fling scroll with another tap
			// then the event.target of the last 'touchend' event will be the element that was under the user's finger
			// when the fling scroll was started, causing FastClick to send a click event to that layer - unless a check
			// is made to ensure that a parent layer was not scrolled before sending a synthetic click (issue #42).
			this.updateScrollParent(targetElement);
		}
	}

	this.trackingClick = true;
	this.trackingClickStart = event.timeStamp;
	this.targetElement = targetElement;

	this.touchStartX = touch.pageX;
	this.touchStartY = touch.pageY;

	// Prevent phantom clicks on fast double-tap (issue #36)
	if ((event.timeStamp - this.lastClickTime) < 200) {
		event.preventDefault();
	}

	return true;
};


/**
 * Based on a touchmove event object, check whether the touch has moved past a boundary since it started.
 *
 * @param {Event} event
 * @returns {boolean}
 */
FastClick.prototype.touchHasMoved = function(event) {
	'use strict';
	var touch = event.changedTouches[0], boundary = this.touchBoundary;

	if (Math.abs(touch.pageX - this.touchStartX) > boundary || Math.abs(touch.pageY - this.touchStartY) > boundary) {
		return true;
	}

	return false;
};


/**
 * Update the last position.
 *
 * @param {Event} event
 * @returns {boolean}
 */
FastClick.prototype.onTouchMove = function(event) {
	'use strict';
	if (!this.trackingClick) {
		return true;
	}

	// If the touch has moved, cancel the click tracking
	if (this.targetElement !== this.getTargetElementFromEventTarget(event.target) || this.touchHasMoved(event)) {
		this.trackingClick = false;
		this.targetElement = null;
	}

	return true;
};


/**
 * Attempt to find the labelled control for the given label element.
 *
 * @param {EventTarget|HTMLLabelElement} labelElement
 * @returns {Element|null}
 */
FastClick.prototype.findControl = function(labelElement) {
	'use strict';

	// Fast path for newer browsers supporting the HTML5 control attribute
	if (labelElement.control !== undefined) {
		return labelElement.control;
	}

	// All browsers under test that support touch events also support the HTML5 htmlFor attribute
	if (labelElement.htmlFor) {
		return document.getElementById(labelElement.htmlFor);
	}

	// If no for attribute exists, attempt to retrieve the first labellable descendant element
	// the list of which is defined here: http://www.w3.org/TR/html5/forms.html#category-label
	return labelElement.querySelector('button, input:not([type=hidden]), keygen, meter, output, progress, select, textarea');
};


/**
 * On touch end, determine whether to send a click event at once.
 *
 * @param {Event} event
 * @returns {boolean}
 */
FastClick.prototype.onTouchEnd = function(event) {
	'use strict';
	var forElement, trackingClickStart, targetTagName, scrollParent, touch, targetElement = this.targetElement;

	if (!this.trackingClick) {
		return true;
	}

	// Prevent phantom clicks on fast double-tap (issue #36)
	if ((event.timeStamp - this.lastClickTime) < 200) {
		this.cancelNextClick = true;
		return true;
	}

	// Reset to prevent wrong click cancel on input (issue #156).
	this.cancelNextClick = false;

	this.lastClickTime = event.timeStamp;

	trackingClickStart = this.trackingClickStart;
	this.trackingClick = false;
	this.trackingClickStart = 0;

	// On some iOS devices, the targetElement supplied with the event is invalid if the layer
	// is performing a transition or scroll, and has to be re-detected manually. Note that
	// for this to function correctly, it must be called *after* the event target is checked!
	// See issue #57; also filed as rdar://13048589 .
	if (this.deviceIsIOSWithBadTarget) {
		touch = event.changedTouches[0];

		// In certain cases arguments of elementFromPoint can be negative, so prevent setting targetElement to null
		targetElement = document.elementFromPoint(touch.pageX - window.pageXOffset, touch.pageY - window.pageYOffset) || targetElement;
		targetElement.fastClickScrollParent = this.targetElement.fastClickScrollParent;
	}

	targetTagName = targetElement.tagName.toLowerCase();
	if (targetTagName === 'label') {
		forElement = this.findControl(targetElement);
		if (forElement) {
			this.focus(targetElement);
			if (this.deviceIsAndroid) {
				return false;
			}

			targetElement = forElement;
		}
	} else if (this.needsFocus(targetElement)) {

		// Case 1: If the touch started a while ago (best guess is 100ms based on tests for issue #36) then focus will be triggered anyway. Return early and unset the target element reference so that the subsequent click will be allowed through.
		// Case 2: Without this exception for input elements tapped when the document is contained in an iframe, then any inputted text won't be visible even though the value attribute is updated as the user types (issue #37).
		if ((event.timeStamp - trackingClickStart) > 100 || (this.deviceIsIOS && window.top !== window && targetTagName === 'input')) {
			this.targetElement = null;
			return false;
		}

		this.focus(targetElement);

		// Select elements need the event to go through on iOS 4, otherwise the selector menu won't open.
		if (!this.deviceIsIOS4 || targetTagName !== 'select') {
			this.targetElement = null;
			event.preventDefault();
		}

		return false;
	}

	if (this.deviceIsIOS && !this.deviceIsIOS4) {

		// Don't send a synthetic click event if the target element is contained within a parent layer that was scrolled
		// and this tap is being used to stop the scrolling (usually initiated by a fling - issue #42).
		scrollParent = targetElement.fastClickScrollParent;
		if (scrollParent && scrollParent.fastClickLastScrollTop !== scrollParent.scrollTop) {
			return true;
		}
	}

	// Prevent the actual click from going though - unless the target node is marked as requiring
	// real clicks or if it is in the whitelist in which case only non-programmatic clicks are permitted.
	if (!this.needsClick(targetElement)) {
		event.preventDefault();
		this.sendClick(targetElement, event);
	}

	return false;
};


/**
 * On touch cancel, stop tracking the click.
 *
 * @returns {void}
 */
FastClick.prototype.onTouchCancel = function() {
	'use strict';
	this.trackingClick = false;
	this.targetElement = null;
};


/**
 * Determine mouse events which should be permitted.
 *
 * @param {Event} event
 * @returns {boolean}
 */
FastClick.prototype.onMouse = function(event) {
	'use strict';

	// If a target element was never set (because a touch event was never fired) allow the event
	if (!this.targetElement) {
		return true;
	}

	if (event.forwardedTouchEvent) {
		return true;
	}

	// Programmatically generated events targeting a specific element should be permitted
	if (!event.cancelable) {
		return true;
	}

	// Derive and check the target element to see whether the mouse event needs to be permitted;
	// unless explicitly enabled, prevent non-touch click events from triggering actions,
	// to prevent ghost/doubleclicks.
	if (!this.needsClick(this.targetElement) || this.cancelNextClick) {

		// Prevent any user-added listeners declared on FastClick element from being fired.
		if (event.stopImmediatePropagation) {
			event.stopImmediatePropagation();
		} else {

			// Part of the hack for browsers that don't support Event#stopImmediatePropagation (e.g. Android 2)
			event.propagationStopped = true;
		}

		// Cancel the event
		event.stopPropagation();
		event.preventDefault();

		return false;
	}

	// If the mouse event is permitted, return true for the action to go through.
	return true;
};


/**
 * On actual clicks, determine whether this is a touch-generated click, a click action occurring
 * naturally after a delay after a touch (which needs to be cancelled to avoid duplication), or
 * an actual click which should be permitted.
 *
 * @param {Event} event
 * @returns {boolean}
 */
FastClick.prototype.onClick = function(event) {
	'use strict';
	var permitted;

	// It's possible for another FastClick-like library delivered with third-party code to fire a click event before FastClick does (issue #44). In that case, set the click-tracking flag back to false and return early. This will cause onTouchEnd to return early.
	if (this.trackingClick) {
		this.targetElement = null;
		this.trackingClick = false;
		return true;
	}

	// Very odd behaviour on iOS (issue #18): if a submit element is present inside a form and the user hits enter in the iOS simulator or clicks the Go button on the pop-up OS keyboard the a kind of 'fake' click event will be triggered with the submit-type input element as the target.
	if (event.target.type === 'submit' && event.detail === 0) {
		return true;
	}

	permitted = this.onMouse(event);

	// Only unset targetElement if the click is not permitted. This will ensure that the check for !targetElement in onMouse fails and the browser's click doesn't go through.
	if (!permitted) {
		this.targetElement = null;
	}

	// If clicks are permitted, return true for the action to go through.
	return permitted;
};


/**
 * Remove all FastClick's event listeners.
 *
 * @returns {void}
 */
FastClick.prototype.destroy = function() {
	'use strict';
	var layer = this.layer;

	if (this.deviceIsAndroid) {
		layer.removeEventListener('mouseover', this.onMouse, true);
		layer.removeEventListener('mousedown', this.onMouse, true);
		layer.removeEventListener('mouseup', this.onMouse, true);
	}

	layer.removeEventListener('click', this.onClick, true);
	layer.removeEventListener('touchstart', this.onTouchStart, false);
	layer.removeEventListener('touchmove', this.onTouchMove, false);
	layer.removeEventListener('touchend', this.onTouchEnd, false);
	layer.removeEventListener('touchcancel', this.onTouchCancel, false);
};


/**
 * Check whether FastClick is needed.
 *
 * @param {Element} layer The layer to listen on
 */
FastClick.notNeeded = function(layer) {
	'use strict';
	var metaViewport;

	// Devices that don't support touch don't need FastClick
	if (typeof window.ontouchstart === 'undefined') {
		return true;
	}

	if ((/Chrome\/[0-9]+/).test(navigator.userAgent)) {

		// Chrome on Android with user-scalable="no" doesn't need FastClick (issue #89)
		if (FastClick.prototype.deviceIsAndroid) {
			metaViewport = document.querySelector('meta[name=viewport]');
			if (metaViewport && metaViewport.content.indexOf('user-scalable=no') !== -1) {
				return true;
			}

		// Chrome desktop doesn't need FastClick (issue #15)
		} else {
			return true;
		}
	}

	// IE10 with -ms-touch-action: none, which disables double-tap-to-zoom (issue #97)
	if (layer.style.msTouchAction === 'none') {
		return true;
	}

	return false;
};


/**
 * Factory method for creating a FastClick object
 *
 * @param {Element} layer The layer to listen on
 */
FastClick.attach = function(layer) {
	'use strict';
	return new FastClick(layer);
};


if (typeof define !== 'undefined' && define.amd) {

	// AMD. Register as an anonymous module.
	define(function() {
		'use strict';
		return FastClick;
	});
} else if (typeof module !== 'undefined' && module.exports) {
	module.exports = FastClick.attach;
	module.exports.FastClick = FastClick;
} else {
	window.FastClick = FastClick;
}
;
/*!
 * iScroll v4.2.5 ~ Copyright (c) 2012 Matteo Spinelli, http://cubiq.org
 * Released under MIT license, http://cubiq.org/license
 */
(function(window, doc){
var m = Math,
	dummyStyle = doc.createElement('div').style,
	vendor = (function () {
		var vendors = 't,webkitT,MozT,msT,OT'.split(','),
			t,
			i = 0,
			l = vendors.length;

		for ( ; i < l; i++ ) {
			t = vendors[i] + 'ransform';
			if ( t in dummyStyle ) {
				return vendors[i].substr(0, vendors[i].length - 1);
			}
		}

		return false;
	})(),
	cssVendor = vendor ? '-' + vendor.toLowerCase() + '-' : '',

	// Style properties
	transform = prefixStyle('transform'),
	transitionProperty = prefixStyle('transitionProperty'),
	transitionDuration = prefixStyle('transitionDuration'),
	transformOrigin = prefixStyle('transformOrigin'),
	transitionTimingFunction = prefixStyle('transitionTimingFunction'),
	transitionDelay = prefixStyle('transitionDelay'),

    // Browser capabilities
	isAndroid = (/android/gi).test(navigator.appVersion),
	isIDevice = (/iphone|ipad/gi).test(navigator.appVersion),
	isTouchPad = (/hp-tablet/gi).test(navigator.appVersion),

    has3d = prefixStyle('perspective') in dummyStyle,
    hasTouch = 'ontouchstart' in window && !isTouchPad,
    hasTransform = vendor !== false,
    hasTransitionEnd = prefixStyle('transition') in dummyStyle,

	RESIZE_EV = 'onorientationchange' in window ? 'orientationchange' : 'resize',
	START_EV = hasTouch ? 'touchstart' : 'mousedown',
	MOVE_EV = hasTouch ? 'touchmove' : 'mousemove',
	END_EV = hasTouch ? 'touchend' : 'mouseup',
	CANCEL_EV = hasTouch ? 'touchcancel' : 'mouseup',
	TRNEND_EV = (function () {
		if ( vendor === false ) return false;

		var transitionEnd = {
				''			: 'transitionend',
				'webkit'	: 'webkitTransitionEnd',
				'Moz'		: 'transitionend',
				'O'			: 'otransitionend',
				'ms'		: 'MSTransitionEnd'
			};

		return transitionEnd[vendor];
	})(),

	nextFrame = (function() {
		return window.requestAnimationFrame ||
			window.webkitRequestAnimationFrame ||
			window.mozRequestAnimationFrame ||
			window.oRequestAnimationFrame ||
			window.msRequestAnimationFrame ||
			function(callback) { return setTimeout(callback, 1); };
	})(),
	cancelFrame = (function () {
		return window.cancelRequestAnimationFrame ||
			window.webkitCancelAnimationFrame ||
			window.webkitCancelRequestAnimationFrame ||
			window.mozCancelRequestAnimationFrame ||
			window.oCancelRequestAnimationFrame ||
			window.msCancelRequestAnimationFrame ||
			clearTimeout;
	})(),

	// Helpers
	translateZ = has3d ? ' translateZ(0)' : '',

	// Constructor
	iScroll = function (el, options) {
		var that = this,
			i;

		that.wrapper = typeof el == 'object' ? el : doc.getElementById(el);
		that.wrapper.style.overflow = 'hidden';
		that.scroller = that.wrapper.children[0];

		// Default options
		that.options = {
			hScroll: true,
			vScroll: true,
			x: 0,
			y: 0,
			bounce: true,
			bounceLock: false,
			momentum: true,
			lockDirection: true,
			useTransform: true,
			useTransition: false,
			topOffset: 0,
			checkDOMChanges: false,		// Experimental
			handleClick: true,

			// Scrollbar
			hScrollbar: true,
			vScrollbar: true,
			fixedScrollbar: isAndroid,
			hideScrollbar: isIDevice,
			fadeScrollbar: isIDevice && has3d,
			scrollbarClass: '',

			// Zoom
			zoom: false,
			zoomMin: 1,
			zoomMax: 4,
			doubleTapZoom: 2,
			wheelAction: 'scroll',

			// Snap
			snap: false,
			snapThreshold: 1,

			// Events
			onRefresh: null,
			onBeforeScrollStart: function (e) { e.preventDefault(); },
			onScrollStart: null,
			onBeforeScrollMove: null,
			onScrollMove: null,
			onBeforeScrollEnd: null,
			onScrollEnd: null,
			onTouchEnd: null,
			onDestroy: null,
			onZoomStart: null,
			onZoom: null,
			onZoomEnd: null
		};

		// User defined options
		for (i in options) that.options[i] = options[i];
		
		// Set starting position
		that.x = that.options.x;
		that.y = that.options.y;

		// Normalize options
		that.options.useTransform = hasTransform && that.options.useTransform;
		that.options.hScrollbar = that.options.hScroll && that.options.hScrollbar;
		that.options.vScrollbar = that.options.vScroll && that.options.vScrollbar;
		that.options.zoom = that.options.useTransform && that.options.zoom;
		that.options.useTransition = hasTransitionEnd && that.options.useTransition;

		// Helpers FIX ANDROID BUG!
		// translate3d and scale doesn't work together!
		// Ignoring 3d ONLY WHEN YOU SET that.options.zoom
		if ( that.options.zoom && isAndroid ){
			translateZ = '';
		}
		
		// Set some default styles
		that.scroller.style[transitionProperty] = that.options.useTransform ? cssVendor + 'transform' : 'top left';
		that.scroller.style[transitionDuration] = '0';
		that.scroller.style[transformOrigin] = '0 0';
		if (that.options.useTransition) that.scroller.style[transitionTimingFunction] = 'cubic-bezier(0.33,0.66,0.66,1)';
		
		if (that.options.useTransform) that.scroller.style[transform] = 'translate(' + that.x + 'px,' + that.y + 'px)' + translateZ;
		else that.scroller.style.cssText += ';position:absolute;top:' + that.y + 'px;left:' + that.x + 'px';

		if (that.options.useTransition) that.options.fixedScrollbar = true;

		that.refresh();

		that._bind(RESIZE_EV, window);
		that._bind(START_EV);
		if (!hasTouch) {
			if (that.options.wheelAction != 'none') {
				that._bind('DOMMouseScroll');
				that._bind('mousewheel');
			}
		}

		if (that.options.checkDOMChanges) that.checkDOMTime = setInterval(function () {
			that._checkDOMChanges();
		}, 500);
	};

// Prototype
iScroll.prototype = {
	enabled: true,
	x: 0,
	y: 0,
	steps: [],
	scale: 1,
	currPageX: 0, currPageY: 0,
	pagesX: [], pagesY: [],
	aniTime: null,
	wheelZoomCount: 0,
	
	handleEvent: function (e) {
		var that = this;
		switch(e.type) {
			case START_EV:
				if (!hasTouch && e.button !== 0) return;
				that._start(e);
				break;
			case MOVE_EV: that._move(e); break;
			case END_EV:
			case CANCEL_EV: that._end(e); break;
			case RESIZE_EV: that._resize(); break;
			case 'DOMMouseScroll': case 'mousewheel': that._wheel(e); break;
			case TRNEND_EV: that._transitionEnd(e); break;
		}
	},
	
	_checkDOMChanges: function () {
		if (this.moved || this.zoomed || this.animating ||
			(this.scrollerW == this.scroller.offsetWidth * this.scale && this.scrollerH == this.scroller.offsetHeight * this.scale)) return;

		this.refresh();
	},
	
	_scrollbar: function (dir) {
		var that = this,
			bar;

		if (!that[dir + 'Scrollbar']) {
			if (that[dir + 'ScrollbarWrapper']) {
				if (hasTransform) that[dir + 'ScrollbarIndicator'].style[transform] = '';
				that[dir + 'ScrollbarWrapper'].parentNode.removeChild(that[dir + 'ScrollbarWrapper']);
				that[dir + 'ScrollbarWrapper'] = null;
				that[dir + 'ScrollbarIndicator'] = null;
			}

			return;
		}

		if (!that[dir + 'ScrollbarWrapper']) {
			// Create the scrollbar wrapper
			bar = doc.createElement('div');

			if (that.options.scrollbarClass) bar.className = that.options.scrollbarClass + dir.toUpperCase();
			else bar.style.cssText = 'position:absolute;z-index:100;' + (dir == 'h' ? 'height:7px;bottom:1px;left:2px;right:' + (that.vScrollbar ? '7' : '2') + 'px' : 'width:7px;bottom:' + (that.hScrollbar ? '7' : '2') + 'px;top:2px;right:1px');

			bar.style.cssText += ';pointer-events:none;' + cssVendor + 'transition-property:opacity;' + cssVendor + 'transition-duration:' + (that.options.fadeScrollbar ? '350ms' : '0') + ';overflow:hidden;opacity:' + (that.options.hideScrollbar ? '0' : '1');

			that.wrapper.appendChild(bar);
			that[dir + 'ScrollbarWrapper'] = bar;

			// Create the scrollbar indicator
			bar = doc.createElement('div');
			if (!that.options.scrollbarClass) {
				bar.style.cssText = 'position:absolute;z-index:100;background:rgba(0,0,0,0.5);border:1px solid rgba(255,255,255,0.9);' + cssVendor + 'background-clip:padding-box;' + cssVendor + 'box-sizing:border-box;' + (dir == 'h' ? 'height:100%' : 'width:100%') + ';' + cssVendor + 'border-radius:3px;border-radius:3px';
			}
			bar.style.cssText += ';pointer-events:none;' + cssVendor + 'transition-property:' + cssVendor + 'transform;' + cssVendor + 'transition-timing-function:cubic-bezier(0.33,0.66,0.66,1);' + cssVendor + 'transition-duration:0;' + cssVendor + 'transform: translate(0,0)' + translateZ;
			if (that.options.useTransition) bar.style.cssText += ';' + cssVendor + 'transition-timing-function:cubic-bezier(0.33,0.66,0.66,1)';

			that[dir + 'ScrollbarWrapper'].appendChild(bar);
			that[dir + 'ScrollbarIndicator'] = bar;
		}

		if (dir == 'h') {
			that.hScrollbarSize = that.hScrollbarWrapper.clientWidth;
			that.hScrollbarIndicatorSize = m.max(m.round(that.hScrollbarSize * that.hScrollbarSize / that.scrollerW), 8);
			that.hScrollbarIndicator.style.width = that.hScrollbarIndicatorSize + 'px';
			that.hScrollbarMaxScroll = that.hScrollbarSize - that.hScrollbarIndicatorSize;
			that.hScrollbarProp = that.hScrollbarMaxScroll / that.maxScrollX;
		} else {
			that.vScrollbarSize = that.vScrollbarWrapper.clientHeight;
			that.vScrollbarIndicatorSize = m.max(m.round(that.vScrollbarSize * that.vScrollbarSize / that.scrollerH), 8);
			that.vScrollbarIndicator.style.height = that.vScrollbarIndicatorSize + 'px';
			that.vScrollbarMaxScroll = that.vScrollbarSize - that.vScrollbarIndicatorSize;
			that.vScrollbarProp = that.vScrollbarMaxScroll / that.maxScrollY;
		}

		// Reset position
		that._scrollbarPos(dir, true);
	},
	
	_resize: function () {
		var that = this;
		setTimeout(function () { that.refresh(); }, isAndroid ? 200 : 0);
	},
	
	_pos: function (x, y) {
		if (this.zoomed) return;

		x = this.hScroll ? x : 0;
		y = this.vScroll ? y : 0;

		if (this.options.useTransform) {
			this.scroller.style[transform] = 'translate(' + x + 'px,' + y + 'px) scale(' + this.scale + ')' + translateZ;
		} else {
			x = m.round(x);
			y = m.round(y);
			this.scroller.style.left = x + 'px';
			this.scroller.style.top = y + 'px';
		}

		this.x = x;
		this.y = y;

		this._scrollbarPos('h');
		this._scrollbarPos('v');
	},

	_scrollbarPos: function (dir, hidden) {
		var that = this,
			pos = dir == 'h' ? that.x : that.y,
			size;

		if (!that[dir + 'Scrollbar']) return;

		pos = that[dir + 'ScrollbarProp'] * pos;

		if (pos < 0) {
			if (!that.options.fixedScrollbar) {
				size = that[dir + 'ScrollbarIndicatorSize'] + m.round(pos * 3);
				if (size < 8) size = 8;
				that[dir + 'ScrollbarIndicator'].style[dir == 'h' ? 'width' : 'height'] = size + 'px';
			}
			pos = 0;
		} else if (pos > that[dir + 'ScrollbarMaxScroll']) {
			if (!that.options.fixedScrollbar) {
				size = that[dir + 'ScrollbarIndicatorSize'] - m.round((pos - that[dir + 'ScrollbarMaxScroll']) * 3);
				if (size < 8) size = 8;
				that[dir + 'ScrollbarIndicator'].style[dir == 'h' ? 'width' : 'height'] = size + 'px';
				pos = that[dir + 'ScrollbarMaxScroll'] + (that[dir + 'ScrollbarIndicatorSize'] - size);
			} else {
				pos = that[dir + 'ScrollbarMaxScroll'];
			}
		}

		that[dir + 'ScrollbarWrapper'].style[transitionDelay] = '0';
		that[dir + 'ScrollbarWrapper'].style.opacity = hidden && that.options.hideScrollbar ? '0' : '1';
		that[dir + 'ScrollbarIndicator'].style[transform] = 'translate(' + (dir == 'h' ? pos + 'px,0)' : '0,' + pos + 'px)') + translateZ;
	},
	
	_start: function (e) {
		var that = this,
			point = hasTouch ? e.touches[0] : e,
			matrix, x, y,
			c1, c2;

		if (!that.enabled) return;

		if (that.options.onBeforeScrollStart) that.options.onBeforeScrollStart.call(that, e);

		if (that.options.useTransition || that.options.zoom) that._transitionTime(0);

		that.moved = false;
		that.animating = false;
		that.zoomed = false;
		that.distX = 0;
		that.distY = 0;
		that.absDistX = 0;
		that.absDistY = 0;
		that.dirX = 0;
		that.dirY = 0;

		// Gesture start
		if (that.options.zoom && hasTouch && e.touches.length > 1) {
			c1 = m.abs(e.touches[0].pageX-e.touches[1].pageX);
			c2 = m.abs(e.touches[0].pageY-e.touches[1].pageY);
			that.touchesDistStart = m.sqrt(c1 * c1 + c2 * c2);

			that.originX = m.abs(e.touches[0].pageX + e.touches[1].pageX - that.wrapperOffsetLeft * 2) / 2 - that.x;
			that.originY = m.abs(e.touches[0].pageY + e.touches[1].pageY - that.wrapperOffsetTop * 2) / 2 - that.y;

			if (that.options.onZoomStart) that.options.onZoomStart.call(that, e);
		}

		if (that.options.momentum) {
			if (that.options.useTransform) {
				// Very lame general purpose alternative to CSSMatrix
				matrix = getComputedStyle(that.scroller, null)[transform].replace(/[^0-9\-.,]/g, '').split(',');
				x = +(matrix[12] || matrix[4]);
				y = +(matrix[13] || matrix[5]);
			} else {
				x = +getComputedStyle(that.scroller, null).left.replace(/[^0-9-]/g, '');
				y = +getComputedStyle(that.scroller, null).top.replace(/[^0-9-]/g, '');
			}
			
			if (x != that.x || y != that.y) {
				if (that.options.useTransition) that._unbind(TRNEND_EV);
				else cancelFrame(that.aniTime);
				that.steps = [];
				that._pos(x, y);
				if (that.options.onScrollEnd) that.options.onScrollEnd.call(that);
			}
		}

		that.absStartX = that.x;	// Needed by snap threshold
		that.absStartY = that.y;

		that.startX = that.x;
		that.startY = that.y;
		that.pointX = point.pageX;
		that.pointY = point.pageY;

		that.startTime = e.timeStamp || Date.now();

		if (that.options.onScrollStart) that.options.onScrollStart.call(that, e);

		that._bind(MOVE_EV, window);
		that._bind(END_EV, window);
		that._bind(CANCEL_EV, window);
	},
	
	_move: function (e) {
		var that = this,
			point = hasTouch ? e.touches[0] : e,
			deltaX = point.pageX - that.pointX,
			deltaY = point.pageY - that.pointY,
			newX = that.x + deltaX,
			newY = that.y + deltaY,
			c1, c2, scale,
			timestamp = e.timeStamp || Date.now();

		if (that.options.onBeforeScrollMove) that.options.onBeforeScrollMove.call(that, e);

		// Zoom
		if (that.options.zoom && hasTouch && e.touches.length > 1) {
			c1 = m.abs(e.touches[0].pageX - e.touches[1].pageX);
			c2 = m.abs(e.touches[0].pageY - e.touches[1].pageY);
			that.touchesDist = m.sqrt(c1*c1+c2*c2);

			that.zoomed = true;

			scale = 1 / that.touchesDistStart * that.touchesDist * this.scale;

			if (scale < that.options.zoomMin) scale = 0.5 * that.options.zoomMin * Math.pow(2.0, scale / that.options.zoomMin);
			else if (scale > that.options.zoomMax) scale = 2.0 * that.options.zoomMax * Math.pow(0.5, that.options.zoomMax / scale);

			that.lastScale = scale / this.scale;

			newX = this.originX - this.originX * that.lastScale + this.x;
			newY = this.originY - this.originY * that.lastScale + this.y;

			this.scroller.style[transform] = 'translate(' + newX + 'px,' + newY + 'px) scale(' + scale + ')' + translateZ;

			if (that.options.onZoom) that.options.onZoom.call(that, e);
			return;
		}

		that.pointX = point.pageX;
		that.pointY = point.pageY;

		// Slow down if outside of the boundaries
		if (newX > 0 || newX < that.maxScrollX) {
			newX = that.options.bounce ? that.x + (deltaX / 2) : newX >= 0 || that.maxScrollX >= 0 ? 0 : that.maxScrollX;
		}
		if (newY > that.minScrollY || newY < that.maxScrollY) {
			newY = that.options.bounce ? that.y + (deltaY / 2) : newY >= that.minScrollY || that.maxScrollY >= 0 ? that.minScrollY : that.maxScrollY;
		}

		that.distX += deltaX;
		that.distY += deltaY;
		that.absDistX = m.abs(that.distX);
		that.absDistY = m.abs(that.distY);

		if (that.absDistX < 6 && that.absDistY < 6) {
			return;
		}

		// Lock direction
		if (that.options.lockDirection) {
			if (that.absDistX > that.absDistY + 5) {
				newY = that.y;
				deltaY = 0;
			} else if (that.absDistY > that.absDistX + 5) {
				newX = that.x;
				deltaX = 0;
			}
		}

		that.moved = true;
		that._pos(newX, newY);
		that.dirX = deltaX > 0 ? -1 : deltaX < 0 ? 1 : 0;
		that.dirY = deltaY > 0 ? -1 : deltaY < 0 ? 1 : 0;

		if (timestamp - that.startTime > 300) {
			that.startTime = timestamp;
			that.startX = that.x;
			that.startY = that.y;
		}
		
		if (that.options.onScrollMove) that.options.onScrollMove.call(that, e);
	},
	
	_end: function (e) {
		if (hasTouch && e.touches.length !== 0) return;

		var that = this,
			point = hasTouch ? e.changedTouches[0] : e,
			target, ev,
			momentumX = { dist:0, time:0 },
			momentumY = { dist:0, time:0 },
			duration = (e.timeStamp || Date.now()) - that.startTime,
			newPosX = that.x,
			newPosY = that.y,
			distX, distY,
			newDuration,
			snap,
			scale;

		that._unbind(MOVE_EV, window);
		that._unbind(END_EV, window);
		that._unbind(CANCEL_EV, window);

		if (that.options.onBeforeScrollEnd) that.options.onBeforeScrollEnd.call(that, e);

		if (that.zoomed) {
			scale = that.scale * that.lastScale;
			scale = Math.max(that.options.zoomMin, scale);
			scale = Math.min(that.options.zoomMax, scale);
			that.lastScale = scale / that.scale;
			that.scale = scale;

			that.x = that.originX - that.originX * that.lastScale + that.x;
			that.y = that.originY - that.originY * that.lastScale + that.y;
			
			that.scroller.style[transitionDuration] = '200ms';
			that.scroller.style[transform] = 'translate(' + that.x + 'px,' + that.y + 'px) scale(' + that.scale + ')' + translateZ;
			
			that.zoomed = false;
			that.refresh();

			if (that.options.onZoomEnd) that.options.onZoomEnd.call(that, e);
			return;
		}

		if (!that.moved) {
			if (hasTouch) {
				if (that.doubleTapTimer && that.options.zoom) {
					// Double tapped
					clearTimeout(that.doubleTapTimer);
					that.doubleTapTimer = null;
					if (that.options.onZoomStart) that.options.onZoomStart.call(that, e);
					that.zoom(that.pointX, that.pointY, that.scale == 1 ? that.options.doubleTapZoom : 1);
					if (that.options.onZoomEnd) {
						setTimeout(function() {
							that.options.onZoomEnd.call(that, e);
						}, 200); // 200 is default zoom duration
					}
				} else if (this.options.handleClick) {
					that.doubleTapTimer = setTimeout(function () {
						that.doubleTapTimer = null;

						// Find the last touched element
						target = point.target;
						while (target.nodeType != 1) target = target.parentNode;

						if (target.tagName != 'SELECT' && target.tagName != 'INPUT' && target.tagName != 'TEXTAREA') {
							ev = doc.createEvent('MouseEvents');
							ev.initMouseEvent('click', true, true, e.view, 1,
								point.screenX, point.screenY, point.clientX, point.clientY,
								e.ctrlKey, e.altKey, e.shiftKey, e.metaKey,
								0, null);
							ev._fake = true;
							target.dispatchEvent(ev);
						}
					}, that.options.zoom ? 250 : 0);
				}
			}

			that._resetPos(400);

			if (that.options.onTouchEnd) that.options.onTouchEnd.call(that, e);
			return;
		}

		if (duration < 300 && that.options.momentum) {
			momentumX = newPosX ? that._momentum(newPosX - that.startX, duration, -that.x, that.scrollerW - that.wrapperW + that.x, that.options.bounce ? that.wrapperW : 0) : momentumX;
			momentumY = newPosY ? that._momentum(newPosY - that.startY, duration, -that.y, (that.maxScrollY < 0 ? that.scrollerH - that.wrapperH + that.y - that.minScrollY : 0), that.options.bounce ? that.wrapperH : 0) : momentumY;

			newPosX = that.x + momentumX.dist;
			newPosY = that.y + momentumY.dist;

			if ((that.x > 0 && newPosX > 0) || (that.x < that.maxScrollX && newPosX < that.maxScrollX)) momentumX = { dist:0, time:0 };
			if ((that.y > that.minScrollY && newPosY > that.minScrollY) || (that.y < that.maxScrollY && newPosY < that.maxScrollY)) momentumY = { dist:0, time:0 };
		}

		if (momentumX.dist || momentumY.dist) {
			newDuration = m.max(m.max(momentumX.time, momentumY.time), 10);

			// Do we need to snap?
			if (that.options.snap) {
				distX = newPosX - that.absStartX;
				distY = newPosY - that.absStartY;
				if (m.abs(distX) < that.options.snapThreshold && m.abs(distY) < that.options.snapThreshold) { that.scrollTo(that.absStartX, that.absStartY, 200); }
				else {
					snap = that._snap(newPosX, newPosY);
					newPosX = snap.x;
					newPosY = snap.y;
					newDuration = m.max(snap.time, newDuration);
				}
			}

			that.scrollTo(m.round(newPosX), m.round(newPosY), newDuration);

			if (that.options.onTouchEnd) that.options.onTouchEnd.call(that, e);
			return;
		}

		// Do we need to snap?
		if (that.options.snap) {
			distX = newPosX - that.absStartX;
			distY = newPosY - that.absStartY;
			if (m.abs(distX) < that.options.snapThreshold && m.abs(distY) < that.options.snapThreshold) that.scrollTo(that.absStartX, that.absStartY, 200);
			else {
				snap = that._snap(that.x, that.y);
				if (snap.x != that.x || snap.y != that.y) that.scrollTo(snap.x, snap.y, snap.time);
			}

			if (that.options.onTouchEnd) that.options.onTouchEnd.call(that, e);
			return;
		}

		that._resetPos(200);
		if (that.options.onTouchEnd) that.options.onTouchEnd.call(that, e);
	},
	
	_resetPos: function (time) {
		var that = this,
			resetX = that.x >= 0 ? 0 : that.x < that.maxScrollX ? that.maxScrollX : that.x,
			resetY = that.y >= that.minScrollY || that.maxScrollY > 0 ? that.minScrollY : that.y < that.maxScrollY ? that.maxScrollY : that.y;

		if (resetX == that.x && resetY == that.y) {
			if (that.moved) {
				that.moved = false;
				if (that.options.onScrollEnd) that.options.onScrollEnd.call(that);		// Execute custom code on scroll end
			}

			if (that.hScrollbar && that.options.hideScrollbar) {
				if (vendor == 'webkit') that.hScrollbarWrapper.style[transitionDelay] = '300ms';
				that.hScrollbarWrapper.style.opacity = '0';
			}
			if (that.vScrollbar && that.options.hideScrollbar) {
				if (vendor == 'webkit') that.vScrollbarWrapper.style[transitionDelay] = '300ms';
				that.vScrollbarWrapper.style.opacity = '0';
			}

			return;
		}

		that.scrollTo(resetX, resetY, time || 0);
	},

	_wheel: function (e) {
		var that = this,
			wheelDeltaX, wheelDeltaY,
			deltaX, deltaY,
			deltaScale;

		if ('wheelDeltaX' in e) {
			wheelDeltaX = e.wheelDeltaX / 12;
			wheelDeltaY = e.wheelDeltaY / 12;
		} else if('wheelDelta' in e) {
			wheelDeltaX = wheelDeltaY = e.wheelDelta / 12;
		} else if ('detail' in e) {
			wheelDeltaX = wheelDeltaY = -e.detail * 3;
		} else {
			return;
		}
		
		if (that.options.wheelAction == 'zoom') {
			deltaScale = that.scale * Math.pow(2, 1/3 * (wheelDeltaY ? wheelDeltaY / Math.abs(wheelDeltaY) : 0));
			if (deltaScale < that.options.zoomMin) deltaScale = that.options.zoomMin;
			if (deltaScale > that.options.zoomMax) deltaScale = that.options.zoomMax;
			
			if (deltaScale != that.scale) {
				if (!that.wheelZoomCount && that.options.onZoomStart) that.options.onZoomStart.call(that, e);
				that.wheelZoomCount++;
				
				that.zoom(e.pageX, e.pageY, deltaScale, 400);
				
				setTimeout(function() {
					that.wheelZoomCount--;
					if (!that.wheelZoomCount && that.options.onZoomEnd) that.options.onZoomEnd.call(that, e);
				}, 400);
			}
			
			return;
		}
		
		deltaX = that.x + wheelDeltaX;
		deltaY = that.y + wheelDeltaY;

		if (deltaX > 0) deltaX = 0;
		else if (deltaX < that.maxScrollX) deltaX = that.maxScrollX;

		if (deltaY > that.minScrollY) deltaY = that.minScrollY;
		else if (deltaY < that.maxScrollY) deltaY = that.maxScrollY;
    
		if (that.maxScrollY < 0) {
			that.scrollTo(deltaX, deltaY, 0);
		}
	},
	
	_transitionEnd: function (e) {
		var that = this;

		if (e.target != that.scroller) return;

		that._unbind(TRNEND_EV);
		
		that._startAni();
	},


	/**
	*
	* Utilities
	*
	*/
	_startAni: function () {
		var that = this,
			startX = that.x, startY = that.y,
			startTime = Date.now(),
			step, easeOut,
			animate;

		if (that.animating) return;
		
		if (!that.steps.length) {
			that._resetPos(400);
			return;
		}
		
		step = that.steps.shift();
		
		if (step.x == startX && step.y == startY) step.time = 0;

		that.animating = true;
		that.moved = true;
		
		if (that.options.useTransition) {
			that._transitionTime(step.time);
			that._pos(step.x, step.y);
			that.animating = false;
			if (step.time) that._bind(TRNEND_EV);
			else that._resetPos(0);
			return;
		}

		animate = function () {
			var now = Date.now(),
				newX, newY;

			if (now >= startTime + step.time) {
				that._pos(step.x, step.y);
				that.animating = false;
				if (that.options.onAnimationEnd) that.options.onAnimationEnd.call(that);			// Execute custom code on animation end
				that._startAni();
				return;
			}

			now = (now - startTime) / step.time - 1;
			easeOut = m.sqrt(1 - now * now);
			newX = (step.x - startX) * easeOut + startX;
			newY = (step.y - startY) * easeOut + startY;
			that._pos(newX, newY);
			if (that.animating) that.aniTime = nextFrame(animate);
		};

		animate();
	},

	_transitionTime: function (time) {
		time += 'ms';
		this.scroller.style[transitionDuration] = time;
		if (this.hScrollbar) this.hScrollbarIndicator.style[transitionDuration] = time;
		if (this.vScrollbar) this.vScrollbarIndicator.style[transitionDuration] = time;
	},

	_momentum: function (dist, time, maxDistUpper, maxDistLower, size) {
		var deceleration = 0.0006,
			speed = m.abs(dist) / time,
			newDist = (speed * speed) / (2 * deceleration),
			newTime = 0, outsideDist = 0;

		// Proportinally reduce speed if we are outside of the boundaries
		if (dist > 0 && newDist > maxDistUpper) {
			outsideDist = size / (6 / (newDist / speed * deceleration));
			maxDistUpper = maxDistUpper + outsideDist;
			speed = speed * maxDistUpper / newDist;
			newDist = maxDistUpper;
		} else if (dist < 0 && newDist > maxDistLower) {
			outsideDist = size / (6 / (newDist / speed * deceleration));
			maxDistLower = maxDistLower + outsideDist;
			speed = speed * maxDistLower / newDist;
			newDist = maxDistLower;
		}

		newDist = newDist * (dist < 0 ? -1 : 1);
		newTime = speed / deceleration;

		return { dist: newDist, time: m.round(newTime) };
	},

	_offset: function (el) {
		var left = -el.offsetLeft,
			top = -el.offsetTop;
			
		while (el = el.offsetParent) {
			left -= el.offsetLeft;
			top -= el.offsetTop;
		}
		
		if (el != this.wrapper) {
			left *= this.scale;
			top *= this.scale;
		}

		return { left: left, top: top };
	},

	_snap: function (x, y) {
		var that = this,
			i, l,
			page, time,
			sizeX, sizeY;

		// Check page X
		page = that.pagesX.length - 1;
		for (i=0, l=that.pagesX.length; i<l; i++) {
			if (x >= that.pagesX[i]) {
				page = i;
				break;
			}
		}
		if (page == that.currPageX && page > 0 && that.dirX < 0) page--;
		x = that.pagesX[page];
		sizeX = m.abs(x - that.pagesX[that.currPageX]);
		sizeX = sizeX ? m.abs(that.x - x) / sizeX * 500 : 0;
		that.currPageX = page;

		// Check page Y
		page = that.pagesY.length-1;
		for (i=0; i<page; i++) {
			if (y >= that.pagesY[i]) {
				page = i;
				break;
			}
		}
		if (page == that.currPageY && page > 0 && that.dirY < 0) page--;
		y = that.pagesY[page];
		sizeY = m.abs(y - that.pagesY[that.currPageY]);
		sizeY = sizeY ? m.abs(that.y - y) / sizeY * 500 : 0;
		that.currPageY = page;

		// Snap with constant speed (proportional duration)
		time = m.round(m.max(sizeX, sizeY)) || 200;

		return { x: x, y: y, time: time };
	},

	_bind: function (type, el, bubble) {
		(el || this.scroller).addEventListener(type, this, !!bubble);
	},

	_unbind: function (type, el, bubble) {
		(el || this.scroller).removeEventListener(type, this, !!bubble);
	},


	/**
	*
	* Public methods
	*
	*/
	destroy: function () {
		var that = this;

		that.scroller.style[transform] = '';

		// Remove the scrollbars
		that.hScrollbar = false;
		that.vScrollbar = false;
		that._scrollbar('h');
		that._scrollbar('v');

		// Remove the event listeners
		that._unbind(RESIZE_EV, window);
		that._unbind(START_EV);
		that._unbind(MOVE_EV, window);
		that._unbind(END_EV, window);
		that._unbind(CANCEL_EV, window);
		
		if (!that.options.hasTouch) {
			that._unbind('DOMMouseScroll');
			that._unbind('mousewheel');
		}
		
		if (that.options.useTransition) that._unbind(TRNEND_EV);
		
		if (that.options.checkDOMChanges) clearInterval(that.checkDOMTime);
		
		if (that.options.onDestroy) that.options.onDestroy.call(that);
	},

	refresh: function () {
		var that = this,
			offset,
			i, l,
			els,
			pos = 0,
			page = 0;

		if (that.scale < that.options.zoomMin) that.scale = that.options.zoomMin;
		that.wrapperW = that.wrapper.clientWidth || 1;
		that.wrapperH = that.wrapper.clientHeight || 1;

		that.minScrollY = -that.options.topOffset || 0;
		that.scrollerW = m.round(that.scroller.offsetWidth * that.scale);
		that.scrollerH = m.round((that.scroller.offsetHeight + that.minScrollY) * that.scale);
		that.maxScrollX = that.wrapperW - that.scrollerW;
		that.maxScrollY = that.wrapperH - that.scrollerH + that.minScrollY;
		that.dirX = 0;
		that.dirY = 0;

		if (that.options.onRefresh) that.options.onRefresh.call(that);

		that.hScroll = that.options.hScroll && that.maxScrollX < 0;
		that.vScroll = that.options.vScroll && (!that.options.bounceLock && !that.hScroll || that.scrollerH > that.wrapperH);

		that.hScrollbar = that.hScroll && that.options.hScrollbar;
		that.vScrollbar = that.vScroll && that.options.vScrollbar && that.scrollerH > that.wrapperH;

		offset = that._offset(that.wrapper);
		that.wrapperOffsetLeft = -offset.left;
		that.wrapperOffsetTop = -offset.top;

		// Prepare snap
		if (typeof that.options.snap == 'string') {
			that.pagesX = [];
			that.pagesY = [];
			els = that.scroller.querySelectorAll(that.options.snap);
			for (i=0, l=els.length; i<l; i++) {
				pos = that._offset(els[i]);
				pos.left += that.wrapperOffsetLeft;
				pos.top += that.wrapperOffsetTop;
				that.pagesX[i] = pos.left < that.maxScrollX ? that.maxScrollX : pos.left * that.scale;
				that.pagesY[i] = pos.top < that.maxScrollY ? that.maxScrollY : pos.top * that.scale;
			}
		} else if (that.options.snap) {
			that.pagesX = [];
			while (pos >= that.maxScrollX) {
				that.pagesX[page] = pos;
				pos = pos - that.wrapperW;
				page++;
			}
			if (that.maxScrollX%that.wrapperW) that.pagesX[that.pagesX.length] = that.maxScrollX - that.pagesX[that.pagesX.length-1] + that.pagesX[that.pagesX.length-1];

			pos = 0;
			page = 0;
			that.pagesY = [];
			while (pos >= that.maxScrollY) {
				that.pagesY[page] = pos;
				pos = pos - that.wrapperH;
				page++;
			}
			if (that.maxScrollY%that.wrapperH) that.pagesY[that.pagesY.length] = that.maxScrollY - that.pagesY[that.pagesY.length-1] + that.pagesY[that.pagesY.length-1];
		}

		// Prepare the scrollbars
		that._scrollbar('h');
		that._scrollbar('v');

		if (!that.zoomed) {
			that.scroller.style[transitionDuration] = '0';
			that._resetPos(400);
		}
	},

	scrollTo: function (x, y, time, relative) {
		var that = this,
			step = x,
			i, l;

		that.stop();

		if (!step.length) step = [{ x: x, y: y, time: time, relative: relative }];
		
		for (i=0, l=step.length; i<l; i++) {
			if (step[i].relative) { step[i].x = that.x - step[i].x; step[i].y = that.y - step[i].y; }
			that.steps.push({ x: step[i].x, y: step[i].y, time: step[i].time || 0 });
		}

		that._startAni();
	},

	scrollToElement: function (el, time) {
		var that = this, pos;
		el = el.nodeType ? el : that.scroller.querySelector(el);
		if (!el) return;

		pos = that._offset(el);
		pos.left += that.wrapperOffsetLeft;
		pos.top += that.wrapperOffsetTop;

		pos.left = pos.left > 0 ? 0 : pos.left < that.maxScrollX ? that.maxScrollX : pos.left;
		pos.top = pos.top > that.minScrollY ? that.minScrollY : pos.top < that.maxScrollY ? that.maxScrollY : pos.top;
		time = time === undefined ? m.max(m.abs(pos.left)*2, m.abs(pos.top)*2) : time;

		that.scrollTo(pos.left, pos.top, time);
	},

	scrollToPage: function (pageX, pageY, time) {
		var that = this, x, y;
		
		time = time === undefined ? 400 : time;

		if (that.options.onScrollStart) that.options.onScrollStart.call(that);

		if (that.options.snap) {
			pageX = pageX == 'next' ? that.currPageX+1 : pageX == 'prev' ? that.currPageX-1 : pageX;
			pageY = pageY == 'next' ? that.currPageY+1 : pageY == 'prev' ? that.currPageY-1 : pageY;

			pageX = pageX < 0 ? 0 : pageX > that.pagesX.length-1 ? that.pagesX.length-1 : pageX;
			pageY = pageY < 0 ? 0 : pageY > that.pagesY.length-1 ? that.pagesY.length-1 : pageY;

			that.currPageX = pageX;
			that.currPageY = pageY;
			x = that.pagesX[pageX];
			y = that.pagesY[pageY];
		} else {
			x = -that.wrapperW * pageX;
			y = -that.wrapperH * pageY;
			if (x < that.maxScrollX) x = that.maxScrollX;
			if (y < that.maxScrollY) y = that.maxScrollY;
		}

		that.scrollTo(x, y, time);
	},

	disable: function () {
		this.stop();
		this._resetPos(0);
		this.enabled = false;

		// If disabled after touchstart we make sure that there are no left over events
		this._unbind(MOVE_EV, window);
		this._unbind(END_EV, window);
		this._unbind(CANCEL_EV, window);
	},
	
	enable: function () {
		this.enabled = true;
	},
	
	stop: function () {
		if (this.options.useTransition) this._unbind(TRNEND_EV);
		else cancelFrame(this.aniTime);
		this.steps = [];
		this.moved = false;
		this.animating = false;
	},
	
	zoom: function (x, y, scale, time) {
		var that = this,
			relScale = scale / that.scale;

		if (!that.options.useTransform) return;

		that.zoomed = true;
		time = time === undefined ? 200 : time;
		x = x - that.wrapperOffsetLeft - that.x;
		y = y - that.wrapperOffsetTop - that.y;
		that.x = x - x * relScale + that.x;
		that.y = y - y * relScale + that.y;

		that.scale = scale;
		that.refresh();

		that.x = that.x > 0 ? 0 : that.x < that.maxScrollX ? that.maxScrollX : that.x;
		that.y = that.y > that.minScrollY ? that.minScrollY : that.y < that.maxScrollY ? that.maxScrollY : that.y;

		that.scroller.style[transitionDuration] = time + 'ms';
		that.scroller.style[transform] = 'translate(' + that.x + 'px,' + that.y + 'px) scale(' + scale + ')' + translateZ;
		that.zoomed = false;
	},
	
	isReady: function () {
		return !this.moved && !this.zoomed && !this.animating;
	}
};

function prefixStyle (style) {
	if ( vendor === '' ) return style;

	style = style.charAt(0).toUpperCase() + style.substr(1);
	return vendor + style;
}

dummyStyle = null;	// for the sake of it

if (typeof exports !== 'undefined') exports.iScroll = iScroll;
else window.iScroll = iScroll;

})(window, document);
;
/*! jQuery UI - v1.10.3 - 2013-07-17
* http://jqueryui.com
* Includes: jquery.ui.widget.js
* Copyright 2013 jQuery Foundation and other contributors Licensed MIT */

(function( $, undefined ) {

var uuid = 0,
	slice = Array.prototype.slice,
	_cleanData = $.cleanData;
$.cleanData = function( elems ) {
	for ( var i = 0, elem; (elem = elems[i]) != null; i++ ) {
		try {
			$( elem ).triggerHandler( "remove" );
		// http://bugs.jquery.com/ticket/8235
		} catch( e ) {}
	}
	_cleanData( elems );
};

$.widget = function( name, base, prototype ) {
	var fullName, existingConstructor, constructor, basePrototype,
		// proxiedPrototype allows the provided prototype to remain unmodified
		// so that it can be used as a mixin for multiple widgets (#8876)
		proxiedPrototype = {},
		namespace = name.split( "." )[ 0 ];

	name = name.split( "." )[ 1 ];
	fullName = namespace + "-" + name;

	if ( !prototype ) {
		prototype = base;
		base = $.Widget;
	}

	// create selector for plugin
	$.expr[ ":" ][ fullName.toLowerCase() ] = function( elem ) {
		return !!$.data( elem, fullName );
	};

	$[ namespace ] = $[ namespace ] || {};
	existingConstructor = $[ namespace ][ name ];
	constructor = $[ namespace ][ name ] = function( options, element ) {
		// allow instantiation without "new" keyword
		if ( !this._createWidget ) {
			return new constructor( options, element );
		}

		// allow instantiation without initializing for simple inheritance
		// must use "new" keyword (the code above always passes args)
		if ( arguments.length ) {
			this._createWidget( options, element );
		}
	};
	// extend with the existing constructor to carry over any static properties
	$.extend( constructor, existingConstructor, {
		version: prototype.version,
		// copy the object used to create the prototype in case we need to
		// redefine the widget later
		_proto: $.extend( {}, prototype ),
		// track widgets that inherit from this widget in case this widget is
		// redefined after a widget inherits from it
		_childConstructors: []
	});

	basePrototype = new base();
	// we need to make the options hash a property directly on the new instance
	// otherwise we'll modify the options hash on the prototype that we're
	// inheriting from
	basePrototype.options = $.widget.extend( {}, basePrototype.options );
	$.each( prototype, function( prop, value ) {
		if ( !$.isFunction( value ) ) {
			proxiedPrototype[ prop ] = value;
			return;
		}
		proxiedPrototype[ prop ] = (function() {
			var _super = function() {
					return base.prototype[ prop ].apply( this, arguments );
				},
				_superApply = function( args ) {
					return base.prototype[ prop ].apply( this, args );
				};
			return function() {
				var __super = this._super,
					__superApply = this._superApply,
					returnValue;

				this._super = _super;
				this._superApply = _superApply;

				returnValue = value.apply( this, arguments );

				this._super = __super;
				this._superApply = __superApply;

				return returnValue;
			};
		})();
	});
	constructor.prototype = $.widget.extend( basePrototype, {
		// TODO: remove support for widgetEventPrefix
		// always use the name + a colon as the prefix, e.g., draggable:start
		// don't prefix for widgets that aren't DOM-based
		widgetEventPrefix: existingConstructor ? basePrototype.widgetEventPrefix : name
	}, proxiedPrototype, {
		constructor: constructor,
		namespace: namespace,
		widgetName: name,
		widgetFullName: fullName
	});

	// If this widget is being redefined then we need to find all widgets that
	// are inheriting from it and redefine all of them so that they inherit from
	// the new version of this widget. We're essentially trying to replace one
	// level in the prototype chain.
	if ( existingConstructor ) {
		$.each( existingConstructor._childConstructors, function( i, child ) {
			var childPrototype = child.prototype;

			// redefine the child widget using the same prototype that was
			// originally used, but inherit from the new version of the base
			$.widget( childPrototype.namespace + "." + childPrototype.widgetName, constructor, child._proto );
		});
		// remove the list of existing child constructors from the old constructor
		// so the old child constructors can be garbage collected
		delete existingConstructor._childConstructors;
	} else {
		base._childConstructors.push( constructor );
	}

	$.widget.bridge( name, constructor );
};

$.widget.extend = function( target ) {
	var input = slice.call( arguments, 1 ),
		inputIndex = 0,
		inputLength = input.length,
		key,
		value;
	for ( ; inputIndex < inputLength; inputIndex++ ) {
		for ( key in input[ inputIndex ] ) {
			value = input[ inputIndex ][ key ];
			if ( input[ inputIndex ].hasOwnProperty( key ) && value !== undefined ) {
				// Clone objects
				if ( $.isPlainObject( value ) ) {
					target[ key ] = $.isPlainObject( target[ key ] ) ?
						$.widget.extend( {}, target[ key ], value ) :
						// Don't extend strings, arrays, etc. with objects
						$.widget.extend( {}, value );
				// Copy everything else by reference
				} else {
					target[ key ] = value;
				}
			}
		}
	}
	return target;
};

$.widget.bridge = function( name, object ) {
	var fullName = object.prototype.widgetFullName || name;
	$.fn[ name ] = function( options ) {
		var isMethodCall = typeof options === "string",
			args = slice.call( arguments, 1 ),
			returnValue = this;

		// allow multiple hashes to be passed on init
		options = !isMethodCall && args.length ?
			$.widget.extend.apply( null, [ options ].concat(args) ) :
			options;

		if ( isMethodCall ) {
			this.each(function() {
				var methodValue,
					instance = $.data( this, fullName );
				if ( !instance ) {
					return $.error( "cannot call methods on " + name + " prior to initialization; " +
						"attempted to call method '" + options + "'" );
				}
				if ( !$.isFunction( instance[options] ) || options.charAt( 0 ) === "_" ) {
					return $.error( "no such method '" + options + "' for " + name + " widget instance" );
				}
				methodValue = instance[ options ].apply( instance, args );
				if ( methodValue !== instance && methodValue !== undefined ) {
					returnValue = methodValue && methodValue.jquery ?
						returnValue.pushStack( methodValue.get() ) :
						methodValue;
					return false;
				}
			});
		} else {
			this.each(function() {
				var instance = $.data( this, fullName );
				if ( instance ) {
					instance.option( options || {} )._init();
				} else {
					$.data( this, fullName, new object( options, this ) );
				}
			});
		}

		return returnValue;
	};
};

$.Widget = function( /* options, element */ ) {};
$.Widget._childConstructors = [];

$.Widget.prototype = {
	widgetName: "widget",
	widgetEventPrefix: "",
	defaultElement: "<div>",
	options: {
		disabled: false,

		// callbacks
		create: null
	},
	_createWidget: function( options, element ) {
		element = $( element || this.defaultElement || this )[ 0 ];
		this.element = $( element );
		this.uuid = uuid++;
		this.eventNamespace = "." + this.widgetName + this.uuid;
		this.options = $.widget.extend( {},
			this.options,
			this._getCreateOptions(),
			options );

		this.bindings = $();
		this.hoverable = $();
		this.focusable = $();

		if ( element !== this ) {
			$.data( element, this.widgetFullName, this );
			this._on( true, this.element, {
				remove: function( event ) {
					if ( event.target === element ) {
						this.destroy();
					}
				}
			});
			this.document = $( element.style ?
				// element within the document
				element.ownerDocument :
				// element is window or document
				element.document || element );
			this.window = $( this.document[0].defaultView || this.document[0].parentWindow );
		}

		this._create();
		this._trigger( "create", null, this._getCreateEventData() );
		this._init();
	},
	_getCreateOptions: $.noop,
	_getCreateEventData: $.noop,
	_create: $.noop,
	_init: $.noop,

	destroy: function() {
		this._destroy();
		// we can probably remove the unbind calls in 2.0
		// all event bindings should go through this._on()
		this.element
			.unbind( this.eventNamespace )
			// 1.9 BC for #7810
			// TODO remove dual storage
			.removeData( this.widgetName )
			.removeData( this.widgetFullName )
			// support: jquery <1.6.3
			// http://bugs.jquery.com/ticket/9413
			.removeData( $.camelCase( this.widgetFullName ) );
		this.widget()
			.unbind( this.eventNamespace )
			.removeAttr( "aria-disabled" )
			.removeClass(
				this.widgetFullName + "-disabled " +
				"ui-state-disabled" );

		// clean up events and states
		this.bindings.unbind( this.eventNamespace );
		this.hoverable.removeClass( "ui-state-hover" );
		this.focusable.removeClass( "ui-state-focus" );
	},
	_destroy: $.noop,

	widget: function() {
		return this.element;
	},

	option: function( key, value ) {
		var options = key,
			parts,
			curOption,
			i;

		if ( arguments.length === 0 ) {
			// don't return a reference to the internal hash
			return $.widget.extend( {}, this.options );
		}

		if ( typeof key === "string" ) {
			// handle nested keys, e.g., "foo.bar" => { foo: { bar: ___ } }
			options = {};
			parts = key.split( "." );
			key = parts.shift();
			if ( parts.length ) {
				curOption = options[ key ] = $.widget.extend( {}, this.options[ key ] );
				for ( i = 0; i < parts.length - 1; i++ ) {
					curOption[ parts[ i ] ] = curOption[ parts[ i ] ] || {};
					curOption = curOption[ parts[ i ] ];
				}
				key = parts.pop();
				if ( value === undefined ) {
					return curOption[ key ] === undefined ? null : curOption[ key ];
				}
				curOption[ key ] = value;
			} else {
				if ( value === undefined ) {
					return this.options[ key ] === undefined ? null : this.options[ key ];
				}
				options[ key ] = value;
			}
		}

		this._setOptions( options );

		return this;
	},
	_setOptions: function( options ) {
		var key;

		for ( key in options ) {
			this._setOption( key, options[ key ] );
		}

		return this;
	},
	_setOption: function( key, value ) {
		this.options[ key ] = value;

		if ( key === "disabled" ) {
			this.widget()
				.toggleClass( this.widgetFullName + "-disabled ui-state-disabled", !!value )
				.attr( "aria-disabled", value );
			this.hoverable.removeClass( "ui-state-hover" );
			this.focusable.removeClass( "ui-state-focus" );
		}

		return this;
	},

	enable: function() {
		return this._setOption( "disabled", false );
	},
	disable: function() {
		return this._setOption( "disabled", true );
	},

	_on: function( suppressDisabledCheck, element, handlers ) {
		var delegateElement,
			instance = this;

		// no suppressDisabledCheck flag, shuffle arguments
		if ( typeof suppressDisabledCheck !== "boolean" ) {
			handlers = element;
			element = suppressDisabledCheck;
			suppressDisabledCheck = false;
		}

		// no element argument, shuffle and use this.element
		if ( !handlers ) {
			handlers = element;
			element = this.element;
			delegateElement = this.widget();
		} else {
			// accept selectors, DOM elements
			element = delegateElement = $( element );
			this.bindings = this.bindings.add( element );
		}

		$.each( handlers, function( event, handler ) {
			function handlerProxy() {
				// allow widgets to customize the disabled handling
				// - disabled as an array instead of boolean
				// - disabled class as method for disabling individual parts
				if ( !suppressDisabledCheck &&
						( instance.options.disabled === true ||
							$( this ).hasClass( "ui-state-disabled" ) ) ) {
					return;
				}
				return ( typeof handler === "string" ? instance[ handler ] : handler )
					.apply( instance, arguments );
			}

			// copy the guid so direct unbinding works
			if ( typeof handler !== "string" ) {
				handlerProxy.guid = handler.guid =
					handler.guid || handlerProxy.guid || $.guid++;
			}

			var match = event.match( /^(\w+)\s*(.*)$/ ),
				eventName = match[1] + instance.eventNamespace,
				selector = match[2];
			if ( selector ) {
				delegateElement.delegate( selector, eventName, handlerProxy );
			} else {
				element.bind( eventName, handlerProxy );
			}
		});
	},

	_off: function( element, eventName ) {
		eventName = (eventName || "").split( " " ).join( this.eventNamespace + " " ) + this.eventNamespace;
		element.unbind( eventName ).undelegate( eventName );
	},

	_delay: function( handler, delay ) {
		function handlerProxy() {
			return ( typeof handler === "string" ? instance[ handler ] : handler )
				.apply( instance, arguments );
		}
		var instance = this;
		return setTimeout( handlerProxy, delay || 0 );
	},

	_hoverable: function( element ) {
		this.hoverable = this.hoverable.add( element );
		this._on( element, {
			mouseenter: function( event ) {
				$( event.currentTarget ).addClass( "ui-state-hover" );
			},
			mouseleave: function( event ) {
				$( event.currentTarget ).removeClass( "ui-state-hover" );
			}
		});
	},

	_focusable: function( element ) {
		this.focusable = this.focusable.add( element );
		this._on( element, {
			focusin: function( event ) {
				$( event.currentTarget ).addClass( "ui-state-focus" );
			},
			focusout: function( event ) {
				$( event.currentTarget ).removeClass( "ui-state-focus" );
			}
		});
	},

	_trigger: function( type, event, data ) {
		var prop, orig,
			callback = this.options[ type ];

		data = data || {};
		event = $.Event( event );
		event.type = ( type === this.widgetEventPrefix ?
			type :
			this.widgetEventPrefix + type ).toLowerCase();
		// the original event may come from any element
		// so we need to reset the target on the new event
		event.target = this.element[ 0 ];

		// copy original event properties over to the new event
		orig = event.originalEvent;
		if ( orig ) {
			for ( prop in orig ) {
				if ( !( prop in event ) ) {
					event[ prop ] = orig[ prop ];
				}
			}
		}

		this.element.trigger( event, data );
		return !( $.isFunction( callback ) &&
			callback.apply( this.element[0], [ event ].concat( data ) ) === false ||
			event.isDefaultPrevented() );
	}
};

$.each( { show: "fadeIn", hide: "fadeOut" }, function( method, defaultEffect ) {
	$.Widget.prototype[ "_" + method ] = function( element, options, callback ) {
		if ( typeof options === "string" ) {
			options = { effect: options };
		}
		var hasOptions,
			effectName = !options ?
				method :
				options === true || typeof options === "number" ?
					defaultEffect :
					options.effect || defaultEffect;
		options = options || {};
		if ( typeof options === "number" ) {
			options = { duration: options };
		}
		hasOptions = !$.isEmptyObject( options );
		options.complete = callback;
		if ( options.delay ) {
			element.delay( options.delay );
		}
		if ( hasOptions && $.effects && $.effects.effect[ effectName ] ) {
			element[ method ]( options );
		} else if ( effectName !== method && element[ effectName ] ) {
			element[ effectName ]( options.duration, options.easing, callback );
		} else {
			element.queue(function( next ) {
				$( this )[ method ]();
				if ( callback ) {
					callback.call( element[ 0 ] );
				}
				next();
			});
		}
	};
});

})( jQuery );
;
/*
 * jQuery Easing v1.3 - http://gsgd.co.uk/sandbox/jquery/easing/
 *
 * Uses the built in easing capabilities added In jQuery 1.1
 * to offer multiple easing options
 *
 * TERMS OF USE - jQuery Easing
 *
 * Open source under the BSD License.
 *
 * Copyright © 2008 George McGinley Smith
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without modification,
 * are permitted provided that the following conditions are met:
 *
 * Redistributions of source code must retain the above copyright notice, this list of
 * conditions and the following disclaimer.
 * Redistributions in binary form must reproduce the above copyright notice, this list
 * of conditions and the following disclaimer in the documentation and/or other materials
 * provided with the distribution.
 *
 * Neither the name of the author nor the names of contributors may be used to endorse
 * or promote products derived from this software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND ANY
 * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
 * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE
 *  COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
 *  EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE
 *  GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED
 * AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
 *  NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED
 * OF THE POSSIBILITY OF SUCH DAMAGE.
 *
*/

// t: current time, b: begInnIng value, c: change In value, d: duration
jQuery.easing['jswing'] = jQuery.easing['swing'];

jQuery.extend( jQuery.easing,
{
	def: 'easeOutQuad',
	swing: function (x, t, b, c, d) {
		//alert(jQuery.easing.default);
		return jQuery.easing[jQuery.easing.def](x, t, b, c, d);
	},
	easeInQuad: function (x, t, b, c, d) {
		return c*(t/=d)*t + b;
	},
	easeOutQuad: function (x, t, b, c, d) {
		return -c *(t/=d)*(t-2) + b;
	},
	easeInOutQuad: function (x, t, b, c, d) {
		if ((t/=d/2) < 1) return c/2*t*t + b;
		return -c/2 * ((--t)*(t-2) - 1) + b;
	},
	easeInCubic: function (x, t, b, c, d) {
		return c*(t/=d)*t*t + b;
	},
	easeOutCubic: function (x, t, b, c, d) {
		return c*((t=t/d-1)*t*t + 1) + b;
	},
	easeInOutCubic: function (x, t, b, c, d) {
		if ((t/=d/2) < 1) return c/2*t*t*t + b;
		return c/2*((t-=2)*t*t + 2) + b;
	},
	easeInQuart: function (x, t, b, c, d) {
		return c*(t/=d)*t*t*t + b;
	},
	easeOutQuart: function (x, t, b, c, d) {
		return -c * ((t=t/d-1)*t*t*t - 1) + b;
	},
	easeInOutQuart: function (x, t, b, c, d) {
		if ((t/=d/2) < 1) return c/2*t*t*t*t + b;
		return -c/2 * ((t-=2)*t*t*t - 2) + b;
	},
	easeInQuint: function (x, t, b, c, d) {
		return c*(t/=d)*t*t*t*t + b;
	},
	easeOutQuint: function (x, t, b, c, d) {
		return c*((t=t/d-1)*t*t*t*t + 1) + b;
	},
	easeInOutQuint: function (x, t, b, c, d) {
		if ((t/=d/2) < 1) return c/2*t*t*t*t*t + b;
		return c/2*((t-=2)*t*t*t*t + 2) + b;
	},
	easeInSine: function (x, t, b, c, d) {
		return -c * Math.cos(t/d * (Math.PI/2)) + c + b;
	},
	easeOutSine: function (x, t, b, c, d) {
		return c * Math.sin(t/d * (Math.PI/2)) + b;
	},
	easeInOutSine: function (x, t, b, c, d) {
		return -c/2 * (Math.cos(Math.PI*t/d) - 1) + b;
	},
	easeInExpo: function (x, t, b, c, d) {
		return (t==0) ? b : c * Math.pow(2, 10 * (t/d - 1)) + b;
	},
	easeOutExpo: function (x, t, b, c, d) {
		return (t==d) ? b+c : c * (-Math.pow(2, -10 * t/d) + 1) + b;
	},
	easeInOutExpo: function (x, t, b, c, d) {
		if (t==0) return b;
		if (t==d) return b+c;
		if ((t/=d/2) < 1) return c/2 * Math.pow(2, 10 * (t - 1)) + b;
		return c/2 * (-Math.pow(2, -10 * --t) + 2) + b;
	},
	easeInCirc: function (x, t, b, c, d) {
		return -c * (Math.sqrt(1 - (t/=d)*t) - 1) + b;
	},
	easeOutCirc: function (x, t, b, c, d) {
		return c * Math.sqrt(1 - (t=t/d-1)*t) + b;
	},
	easeInOutCirc: function (x, t, b, c, d) {
		if ((t/=d/2) < 1) return -c/2 * (Math.sqrt(1 - t*t) - 1) + b;
		return c/2 * (Math.sqrt(1 - (t-=2)*t) + 1) + b;
	},
	easeInElastic: function (x, t, b, c, d) {
		var s=1.70158;var p=0;var a=c;
		if (t==0) return b;  if ((t/=d)==1) return b+c;  if (!p) p=d*.3;
		if (a < Math.abs(c)) { a=c; var s=p/4; }
		else var s = p/(2*Math.PI) * Math.asin (c/a);
		return -(a*Math.pow(2,10*(t-=1)) * Math.sin( (t*d-s)*(2*Math.PI)/p )) + b;
	},
	easeOutElastic: function (x, t, b, c, d) {
		var s=1.70158;var p=0;var a=c;
		if (t==0) return b;  if ((t/=d)==1) return b+c;  if (!p) p=d*.3;
		if (a < Math.abs(c)) { a=c; var s=p/4; }
		else var s = p/(2*Math.PI) * Math.asin (c/a);
		return a*Math.pow(2,-10*t) * Math.sin( (t*d-s)*(2*Math.PI)/p ) + c + b;
	},
	easeInOutElastic: function (x, t, b, c, d) {
		var s=1.70158;var p=0;var a=c;
		if (t==0) return b;  if ((t/=d/2)==2) return b+c;  if (!p) p=d*(.3*1.5);
		if (a < Math.abs(c)) { a=c; var s=p/4; }
		else var s = p/(2*Math.PI) * Math.asin (c/a);
		if (t < 1) return -.5*(a*Math.pow(2,10*(t-=1)) * Math.sin( (t*d-s)*(2*Math.PI)/p )) + b;
		return a*Math.pow(2,-10*(t-=1)) * Math.sin( (t*d-s)*(2*Math.PI)/p )*.5 + c + b;
	},
	easeInBack: function (x, t, b, c, d, s) {
		if (s == undefined) s = 1.70158;
		return c*(t/=d)*t*((s+1)*t - s) + b;
	},
	easeOutBack: function (x, t, b, c, d, s) {
		if (s == undefined) s = 1.70158;
		return c*((t=t/d-1)*t*((s+1)*t + s) + 1) + b;
	},
	easeInOutBack: function (x, t, b, c, d, s) {
		if (s == undefined) s = 1.70158;
		if ((t/=d/2) < 1) return c/2*(t*t*(((s*=(1.525))+1)*t - s)) + b;
		return c/2*((t-=2)*t*(((s*=(1.525))+1)*t + s) + 2) + b;
	},
	easeInBounce: function (x, t, b, c, d) {
		return c - jQuery.easing.easeOutBounce (x, d-t, 0, c, d) + b;
	},
	easeOutBounce: function (x, t, b, c, d) {
		if ((t/=d) < (1/2.75)) {
			return c*(7.5625*t*t) + b;
		} else if (t < (2/2.75)) {
			return c*(7.5625*(t-=(1.5/2.75))*t + .75) + b;
		} else if (t < (2.5/2.75)) {
			return c*(7.5625*(t-=(2.25/2.75))*t + .9375) + b;
		} else {
			return c*(7.5625*(t-=(2.625/2.75))*t + .984375) + b;
		}
	},
	easeInOutBounce: function (x, t, b, c, d) {
		if (t < d/2) return jQuery.easing.easeInBounce (x, t*2, 0, c, d) * .5 + b;
		return jQuery.easing.easeOutBounce (x, t*2-d, 0, c, d) * .5 + c*.5 + b;
	}
});

/*
 *
 * TERMS OF USE - EASING EQUATIONS
 *
 * Open source under the BSD License.
 *
 * Copyright © 2001 Robert Penner
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without modification,
 * are permitted provided that the following conditions are met:
 *
 * Redistributions of source code must retain the above copyright notice, this list of
 * conditions and the following disclaimer.
 * Redistributions in binary form must reproduce the above copyright notice, this list
 * of conditions and the following disclaimer in the documentation and/or other materials
 * provided with the distribution.
 *
 * Neither the name of the author nor the names of contributors may be used to endorse
 * or promote products derived from this software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND ANY
 * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
 * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE
 *  COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
 *  EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE
 *  GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED
 * AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
 *  NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED
 * OF THE POSSIBILITY OF SUCH DAMAGE.
 *
 */;
/*!
 * jQuery Transit - CSS3 transitions and transformations
 * (c) 2011-2012 Rico Sta. Cruz <rico@ricostacruz.com>
 * MIT Licensed.
 *
 * http://ricostacruz.com/jquery.transit
 * http://github.com/rstacruz/jquery.transit
 */
(function(k){k.transit={version:"0.9.9",propertyMap:{marginLeft:"margin",marginRight:"margin",marginBottom:"margin",marginTop:"margin",paddingLeft:"padding",paddingRight:"padding",paddingBottom:"padding",paddingTop:"padding"},enabled:true,useTransitionEnd:false};var d=document.createElement("div");var q={};function b(v){if(v in d.style){return v}var u=["Moz","Webkit","O","ms"];var r=v.charAt(0).toUpperCase()+v.substr(1);if(v in d.style){return v}for(var t=0;t<u.length;++t){var s=u[t]+r;if(s in d.style){return s}}}function e(){d.style[q.transform]="";d.style[q.transform]="rotateY(90deg)";return d.style[q.transform]!==""}var a=navigator.userAgent.toLowerCase().indexOf("chrome")>-1;q.transition=b("transition");q.transitionDelay=b("transitionDelay");q.transform=b("transform");q.transformOrigin=b("transformOrigin");q.transform3d=e();var i={transition:"transitionEnd",MozTransition:"transitionend",OTransition:"oTransitionEnd",WebkitTransition:"webkitTransitionEnd",msTransition:"MSTransitionEnd"};var f=q.transitionEnd=i[q.transition]||null;for(var p in q){if(q.hasOwnProperty(p)&&typeof k.support[p]==="undefined"){k.support[p]=q[p]}}d=null;k.cssEase={_default:"ease","in":"ease-in",out:"ease-out","in-out":"ease-in-out",snap:"cubic-bezier(0,1,.5,1)",easeOutCubic:"cubic-bezier(.215,.61,.355,1)",easeInOutCubic:"cubic-bezier(.645,.045,.355,1)",easeInCirc:"cubic-bezier(.6,.04,.98,.335)",easeOutCirc:"cubic-bezier(.075,.82,.165,1)",easeInOutCirc:"cubic-bezier(.785,.135,.15,.86)",easeInExpo:"cubic-bezier(.95,.05,.795,.035)",easeOutExpo:"cubic-bezier(.19,1,.22,1)",easeInOutExpo:"cubic-bezier(1,0,0,1)",easeInQuad:"cubic-bezier(.55,.085,.68,.53)",easeOutQuad:"cubic-bezier(.25,.46,.45,.94)",easeInOutQuad:"cubic-bezier(.455,.03,.515,.955)",easeInQuart:"cubic-bezier(.895,.03,.685,.22)",easeOutQuart:"cubic-bezier(.165,.84,.44,1)",easeInOutQuart:"cubic-bezier(.77,0,.175,1)",easeInQuint:"cubic-bezier(.755,.05,.855,.06)",easeOutQuint:"cubic-bezier(.23,1,.32,1)",easeInOutQuint:"cubic-bezier(.86,0,.07,1)",easeInSine:"cubic-bezier(.47,0,.745,.715)",easeOutSine:"cubic-bezier(.39,.575,.565,1)",easeInOutSine:"cubic-bezier(.445,.05,.55,.95)",easeInBack:"cubic-bezier(.6,-.28,.735,.045)",easeOutBack:"cubic-bezier(.175, .885,.32,1.275)",easeInOutBack:"cubic-bezier(.68,-.55,.265,1.55)"};k.cssHooks["transit:transform"]={get:function(r){return k(r).data("transform")||new j()},set:function(s,r){var t=r;if(!(t instanceof j)){t=new j(t)}if(q.transform==="WebkitTransform"&&!a){s.style[q.transform]=t.toString(true)}else{s.style[q.transform]=t.toString()}k(s).data("transform",t)}};k.cssHooks.transform={set:k.cssHooks["transit:transform"].set};if(k.fn.jquery<"1.8"){k.cssHooks.transformOrigin={get:function(r){return r.style[q.transformOrigin]},set:function(r,s){r.style[q.transformOrigin]=s}};k.cssHooks.transition={get:function(r){return r.style[q.transition]},set:function(r,s){r.style[q.transition]=s}}}n("scale");n("translate");n("rotate");n("rotateX");n("rotateY");n("rotate3d");n("perspective");n("skewX");n("skewY");n("x",true);n("y",true);function j(r){if(typeof r==="string"){this.parse(r)}return this}j.prototype={setFromString:function(t,s){var r=(typeof s==="string")?s.split(","):(s.constructor===Array)?s:[s];r.unshift(t);j.prototype.set.apply(this,r)},set:function(s){var r=Array.prototype.slice.apply(arguments,[1]);if(this.setter[s]){this.setter[s].apply(this,r)}else{this[s]=r.join(",")}},get:function(r){if(this.getter[r]){return this.getter[r].apply(this)}else{return this[r]||0}},setter:{rotate:function(r){this.rotate=o(r,"deg")},rotateX:function(r){this.rotateX=o(r,"deg")},rotateY:function(r){this.rotateY=o(r,"deg")},scale:function(r,s){if(s===undefined){s=r}this.scale=r+","+s},skewX:function(r){this.skewX=o(r,"deg")},skewY:function(r){this.skewY=o(r,"deg")},perspective:function(r){this.perspective=o(r,"px")},x:function(r){this.set("translate",r,null)},y:function(r){this.set("translate",null,r)},translate:function(r,s){if(this._translateX===undefined){this._translateX=0}if(this._translateY===undefined){this._translateY=0}if(r!==null&&r!==undefined){this._translateX=o(r,"px")}if(s!==null&&s!==undefined){this._translateY=o(s,"px")}this.translate=this._translateX+","+this._translateY}},getter:{x:function(){return this._translateX||0},y:function(){return this._translateY||0},scale:function(){var r=(this.scale||"1,1").split(",");if(r[0]){r[0]=parseFloat(r[0])}if(r[1]){r[1]=parseFloat(r[1])}return(r[0]===r[1])?r[0]:r},rotate3d:function(){var t=(this.rotate3d||"0,0,0,0deg").split(",");for(var r=0;r<=3;++r){if(t[r]){t[r]=parseFloat(t[r])}}if(t[3]){t[3]=o(t[3],"deg")}return t}},parse:function(s){var r=this;s.replace(/([a-zA-Z0-9]+)\((.*?)\)/g,function(t,v,u){r.setFromString(v,u)})},toString:function(t){var s=[];for(var r in this){if(this.hasOwnProperty(r)){if((!q.transform3d)&&((r==="rotateX")||(r==="rotateY")||(r==="perspective")||(r==="transformOrigin"))){continue}if(r[0]!=="_"){if(t&&(r==="scale")){s.push(r+"3d("+this[r]+",1)")}else{if(t&&(r==="translate")){s.push(r+"3d("+this[r]+",0)")}else{s.push(r+"("+this[r]+")")}}}}}return s.join(" ")}};function m(s,r,t){if(r===true){s.queue(t)}else{if(r){s.queue(r,t)}else{t()}}}function h(s){var r=[];k.each(s,function(t){t=k.camelCase(t);t=k.transit.propertyMap[t]||k.cssProps[t]||t;t=c(t);if(k.inArray(t,r)===-1){r.push(t)}});return r}function g(s,v,x,r){var t=h(s);if(k.cssEase[x]){x=k.cssEase[x]}var w=""+l(v)+" "+x;if(parseInt(r,10)>0){w+=" "+l(r)}var u=[];k.each(t,function(z,y){u.push(y+" "+w)});return u.join(", ")}k.fn.transition=k.fn.transit=function(z,s,y,C){var D=this;var u=0;var w=true;if(typeof s==="function"){C=s;s=undefined}if(typeof y==="function"){C=y;y=undefined}if(typeof z.easing!=="undefined"){y=z.easing;delete z.easing}if(typeof z.duration!=="undefined"){s=z.duration;delete z.duration}if(typeof z.complete!=="undefined"){C=z.complete;delete z.complete}if(typeof z.queue!=="undefined"){w=z.queue;delete z.queue}if(typeof z.delay!=="undefined"){u=z.delay;delete z.delay}if(typeof s==="undefined"){s=k.fx.speeds._default}if(typeof y==="undefined"){y=k.cssEase._default}s=l(s);var E=g(z,s,y,u);var B=k.transit.enabled&&q.transition;var t=B?(parseInt(s,10)+parseInt(u,10)):0;if(t===0){var A=function(F){D.css(z);if(C){C.apply(D)}if(F){F()}};m(D,w,A);return D}var x={};var r=function(H){var G=false;var F=function(){if(G){D.unbind(f,F)}if(t>0){D.each(function(){this.style[q.transition]=(x[this]||null)})}if(typeof C==="function"){C.apply(D)}if(typeof H==="function"){H()}};if((t>0)&&(f)&&(k.transit.useTransitionEnd)){G=true;D.bind(f,F)}else{window.setTimeout(F,t)}D.each(function(){if(t>0){this.style[q.transition]=E}k(this).css(z)})};var v=function(F){this.offsetWidth;r(F)};m(D,w,v);return this};function n(s,r){if(!r){k.cssNumber[s]=true}k.transit.propertyMap[s]=q.transform;k.cssHooks[s]={get:function(v){var u=k(v).css("transit:transform");return u.get(s)},set:function(v,w){var u=k(v).css("transit:transform");u.setFromString(s,w);k(v).css({"transit:transform":u})}}}function c(r){return r.replace(/([A-Z])/g,function(s){return"-"+s.toLowerCase()})}function o(s,r){if((typeof s==="string")&&(!s.match(/^[\-0-9\.]+$/))){return s}else{return""+s+r}}function l(s){var r=s;if(k.fx.speeds[r]){r=k.fx.speeds[r]}return o(r,"ms")}k.transit.getTransitionValue=g})(jQuery);;
/*
  requires jQuery 1.6+ because of using $.prop function
*/
(function( $ ){

  "use strict";

  $.fn.UICheckbox = function() {

    return this.each(function() {

      var options = {
            checkboxHoverClass: 'ui-checkbox--hover'
          },
          $real = $( this ),
          $decor = $( '<span class="ui-checkbox"></span>' ),
          $label = $( 'label[for="' + $real.attr( 'id' ) + '"]' ),
          isRadioButton = $real.hasClass( 'f-checkbox-radio' ),
          $form = $real.parents( 'form' );

      $decor.bind({
        click: function() {
          if ( $real.is( ':disabled' ) ) {
            return;
          }
          $real.focus();
          // change value only if it's checkbox or unchecked radio button (so we do not uncheck radio button)
          if ( !isRadioButton || !$real.get( 0 ).checked ) {
            $real
              .prop( 'checked', !$real.get( 0 ).checked )
              .trigger( 'change' );
          }
        }
      });

      $label.bind({
        mouseover: function() {
          if ( !$real.is( ':disabled' ) ) {
            $decor.addClass( options.checkboxHoverClass );
          }
        },
        mouseleave: function() {
          $decor.removeClass( options.checkboxHoverClass );
        }
      });

      $real.bind({
        change: function() {
          // uncheck other radio buttons if we check this
          if ( isRadioButton && $real.get( 0 ).checked ) {
            $( '[name="' + $real.attr( 'name' ) + '"]' ).each(function() {
              if ( this !== $real.get( 0 ) ) {
                $( this )
                  .prop( 'checked', false )
                  .data( '$decor' ).removeClass( 'ui-checkbox-checked' );
              }
            });
          }
          $decor.toggleClass( 'ui-checkbox-checked', $real.get( 0 ).checked );
          console.log( this, $real.get( 0 ).checked, $decor.hasClass( 'ui-checkbox-checked' ) );
        },
        focus: function() {
          $decor.addClass( options.checkboxHoverClass );
        },
        blur: function() {
          $decor.removeClass( options.checkboxHoverClass );
        },
        disabled: function() {
          if ( $real.is( ':disabled' ) ) {
            $decor.addClass( 'ui-checkbox-disabled' );
            $label.addClass( 'ui-checkbox-label-disabled' );
          } else {
            $decor.removeClass( 'ui-checkbox-disabled' );
            $label.removeClass( 'ui-checkbox-label-disabled' );
          }
        }
      });

      $form.bind( 'reset', function() {
        setTimeout( function() { $real.trigger( 'change' ) }, 1 );
      });

      $decor.toggleClass( 'ui-checkbox-checked', $real.get( 0 ).checked );
      $real.addClass( 'ui-checkbox-val' );
      if ( $real.is( ':disabled' ) ) {
        $decor.addClass( 'ui-checkbox-disabled' );
        $label.addClass( 'ui-checkbox-label-disabled' );
      }
      if ( isRadioButton ) {
        $decor.addClass( 'ui-checkbox-radio' );
      }
      $decor.insertAfter( $real );

      $real.data( '$decor', $decor );

    });

  };

})( jQuery );;
(function( $ ) {

	"use strict";

	// TODO can be optimized by generating getScrollPos/setScrollPos functinos without conditions

	$.widget( 'mm.scroller', {

		scrollbarTpl: [ '<div class="scroller-scrollbar">',
							'<div class="scroller-scrollbar-backward"></div>',
							'<div class="scroller-scrollbar-forward"></div>',
							'<div class="scroller-scrollbar-place">',
								'<div class="scroller-scrollbar-handler"></div>',
							'</div>',
						'</div>' ].join( '' ),

		options: {
			backwardBtnQuery: '.scroller-backward',
			forwardBtnQuery: '.scroller-forward',
			viewportQuery: '.scroller-viewport',
			contentQuery: '.scroller-content',
			scrollDir: 'h', // 'v' - for vertical, 'h' - for horizontal,
			scrollbar: false,
			mouseDisable: false,
			mousewheelStep: 0.1,
			scrollPage: false, // if true then scroll one page and align to children elements
			scrollToDistance: 0.7,
			scrollToDuration: 200,
			scrollToEsaing: 'easeOutQuad'
		},

		_create: function () {

			var that = this;

			that.el = {};
			that.el.$backwardBtn = $( that.options.backwardBtnQuery, that.element );
			that.el.$forwardBtn = $( that.options.forwardBtnQuery, that.element );
			that.el.$viewport = $( that.options.viewportQuery, that.element );
			that.el.$content = $( that.options.contentQuery, that.element );

			// need to keep scroll position instead of getting it from content position
			// because of iScroll which is incompatible with jquery.transit $(...).css('x')
			that.scrollPos = 0;

			that.isTouchDevice = !!( 'ontouchstart' in window );
			that.touchClickEvent = that.isTouchDevice ? 'click' : 'click';
			that.iscroll = null;

			that._updateDimentions();
			that._updateControls();

			if ( that.options.scrollbar && !that.isTouchDevice ) {
				that._initScrollbar();
			}

			that.element.on( 'setScrollPos', $.proxy( that._updateControls, that ) );

			if ( that.isTouchDevice ) {
				// scroll by touch
				that.iscroll = new iScroll( that.el.$viewport.get( 0 ), {
					hScroll: that.options.scrollDir === 'h',
					vScroll: that.options.scrollDir === 'v',
					hScrollbar: that.options.scrollDir === 'h' && that.options.scrollbar,
					vScrollbar: that.options.scrollDir === 'v' && that.options.scrollbar,
					onScrollMove: function() {
						that.scrollPos = -this.x;
					},
					onScrollEnd: function() {
						that.scrollPos = -this.x;
						that._updateControls();
					}
				});
			}

			// scroll by mousewheel
			if ( !that.options.mouseDisable ) {
				that._on( that.el.$viewport, { 'mousewheel': function( evt, delta ) {

					var that = this,
						step = that.options.mousewheelStep <= 1 ? that.options.mousewheelStep * that.el.$viewport.width() : that.options.mousewheelStep;

					that.setScrollPos( delta < 0 ? that.getScrollPos() + step : that.getScrollPos() - step );
					evt.preventDefault();

				}});
			}

			// scroll backward by button
			that._on( that.el.$backwardBtn, (function() {

				var handlers = {};

				handlers[ that.touchClickEvent ] = function() {

					var that = this,
						scrollOn = that.options.scrollToDistance <= 1 ? that._getViewportSize() * that.options.scrollToDistance : that.options.scrollToDistance;

					that.scrollTo( that.scrollPos - scrollOn );

				}

				return handlers;

			})());

			// scroll forward by button
			that._on( that.el.$forwardBtn, (function() {

				var handlers = {};

				handlers[ that.touchClickEvent ] = function() {

					var that = this,
						scrollOn = that.options.scrollToDistance <= 1 ? that._getViewportSize() * that.options.scrollToDistance : that.options.scrollToDistance;

					that.scrollTo( that.scrollPos + scrollOn );

				}

				return handlers;

			})());

			$( window ).on( 'load', $.proxy( that.update, that ) );

		},

		getScrollPos: function() {

			var that = this;

			return that.scrollPos;

		},

		setScrollPos: function( scrollPos ) {

			var that = this;

			scrollPos = Math.min( scrollPos, that.scrollDiff );
			scrollPos = Math.max( scrollPos, 0 );

			if ( that.options.scrollDir === 'h' ) {
				that.isTouchDevice ? that.el.$content.css( 'x', -scrollPos ) : that.el.$viewport.scrollLeft( scrollPos );
			} else {
				that.isTouchDevice ? that.el.$content.css( 'y', -scrollPos ) : that.el.$viewport.scrollTop( scrollPos );
			}

			// update scrollPos for getter
			that.scrollPos = scrollPos;

			// trigger event
			that.element.trigger( 'setScrollPos', { scrollPos: scrollPos } );

		},

		scrollTo: function( scrollTo ) {

			var that = this;

			// prevent action when is animating
			if ( that.isTouchDevice ? that.el.$content.is( ':animated' ) : that.el.$viewport.is( ':animated' ) ) {
			 	return;
			}

			scrollTo = Math.max( scrollTo, 0 );
			scrollTo = Math.min( scrollTo, that.scrollDiff );

			if ( that.isTouchDevice ) {
				that.el.$content.transit( { x: -scrollTo }, that.options.scrollToDuration, that.options.scrollToEsaing, function() {
					that.scrollPos = scrollTo;
					that._updateControls();
				});
			} else {
				that.el.$viewport.animate( { scrollLeft: scrollTo }, that.options.scrollToDuration, that.options.scrollToEsaing, function() {
					that.scrollPos = scrollTo;
					that._updateControls();
				});
			}

		},

		centerTo: function( $elem ) {

			var that = this,
				elemPos = that.options.scrollDir === 'h' ? $elem.offset().left : $elem.offset().top,
				elemSize = that.options.scrollDir === 'h' ? $elem.width() : $elem.height(),
				viewportPos = that.options.scrollDir === 'h' ? that.el.$viewport.offset().left : that.el.$viewport.offset().top,
				scrollTo;

			scrollTo = Math.round( elemPos - viewportPos + that.scrollPos - ( that._getViewportSize() - elemSize ) / 2 );

			that.scrollTo( scrollTo );

		},

		_updateDimentions: function() {

			var that = this;

			if ( that.options.scrollPage ) {
				that.el.$content.children().each(function() {

					if ( that.options.scrollDir === 'h' ) {
						if ( $( this ).get( 0 ).offsetLeft > that.el.$viewport.width() ) {
							that.options.scrollToDistance = $( this ).get( 0 ).offsetLeft;
							return false;
						}
					} else {
						if ( $( this ).get( 0 ).offsetTop > that.el.$viewport.height() ) {
							that.options.scrollToDistance = $( this ).get( 0 ).offsetTop;
							return false;
						}
					}

				});
			}

			that.scrollDiff = Math.max( that._getContentSize() - that._getViewportSize(), 0 );

		},

		_updateControls: function () {

			var that = this,
				scrollPos = that.getScrollPos();

	    	scrollPos === 0 ? that.el.$backwardBtn.hide() : that.el.$backwardBtn.show();
			scrollPos === that.scrollDiff ? that.el.$forwardBtn.hide() : that.el.$forwardBtn.show();

		},

		_getViewportSize: function() {

			var that = this;

			return that.options.scrollDir === 'h' ? that.el.$viewport.width() : that.el.$viewport.height();

		},

		_getContentSize: function() {

			var that = this;

			return that.options.scrollDir === 'h' ? that.el.$content.outerWidth() : that.el.$content.outerHeight();

		},

		update: function() {

			var that = this;

			that._updateDimentions();
			// update current scroll pos
			that.scrollPos = Math.max( that.scrollPos, 0 );
			that.scrollPos = Math.min( that.scrollPos, that.scrollDiff );
			that._updateControls();
			if ( that.iscroll ) {
				setTimeout(function() {
					that.iscroll.refresh();
					that.element.trigger( 'update' );
				}, 1 );
			} else {
				that.element.trigger( 'update' );
			}

		},

		_initScrollbar: function() {

			var that = this,
				scrollbarDiff = 0,
				startHandlerPos = 0,
				startDragPos = 0;

			function _getPlaceSize() {

				return that.options.scrollDir === 'h' ? that.el.$scrollbarPlace.width() : that.el.$scrollbarPlace.height();

			}

			function _updateHandlerPos() {

				if ( that.scrollDiff > 0 ) {
					_setHandlerPos( that.getScrollPos() / that.scrollDiff * scrollbarDiff );
					that.el.$scrollbar.removeClass( 'scroller-scrollbar--disabled' );
				} else {
					that.el.$scrollbar.addClass( 'scroller-scrollbar--disabled' );
				}

			}

			function _setHandlerPos( pos ) {

				pos = Math.min( pos, scrollbarDiff );
				pos = Math.max( pos, 0 );

				if ( that.options.scrollDir === 'h' ) {
					that.el.$scrollbarHandler.css( 'left', pos );
				} else {
					that.el.$scrollbarHandler.css( 'top', pos );
				}

			}

			function _getHandlerPos() {

				return parseInt( that.options.scrollDir === 'h' ? that.el.$scrollbarHandler.css( 'left' ) : that.el.$scrollbarHandler.css( 'top' ) );

			}

			function _setHandlerSize( size ) {

				if ( that.options.scrollDir === 'h' ) {
					that.el.$scrollbarHandler.width( size );
				} else {
					that.el.$scrollbarHandler.height( size );
				}

			}

			function _updateDimentions() {

				var handlerSize = Math.min( that._getViewportSize() / that._getContentSize(), 1 ) * _getPlaceSize();

				scrollbarDiff = Math.max( _getPlaceSize() - handlerSize, 0 );
				_setHandlerSize( handlerSize );

			}

			function _dontStartSelectForIE8() {

				return false;

			}

			function _onHandlerMousedown( evt ) {

				evt.preventDefault();

				startHandlerPos = _getHandlerPos();
				startDragPos = that.options.scrollDir === 'h' ? evt.pageX : evt.pageY;

				$( document ).on( 'selectstart', _dontStartSelectForIE8 );
				$( document.body ).on( 'mousemove', _onHandlerMousemove );
				$( document.body ).on( 'mouseup blur', _onHandlerMouseup );

			}

			function _onHandlerMousemove( evt ) {

				var handlerPos = startHandlerPos + ( that.options.scrollDir === 'h' ? evt.pageX : evt.pageY ) - startDragPos;

				that.setScrollPos( handlerPos / scrollbarDiff * that.scrollDiff );

			}

			function _onHandlerMouseup( evt ) {

				$( document.body ).off( 'mousemove', _onHandlerMousemove );
				$( document.body ).off( 'mouseup blur', _onHandlerMouseup );
				$( document ).off( 'selectstart', _dontStartSelectForIE8 );

			}

			that.el.$scrollbar = $( that.scrollbarTpl ).appendTo( that.element );
			that.el.$scrollbarPlace = that.el.$scrollbar.find( '.scroller-scrollbar-place' );
			that.el.$scrollbarHandler = that.el.$scrollbar.find( '.scroller-scrollbar-handler' );
			that.el.$scrollbarForwardBtn = that.el.$scrollbar.find( '.scroller-scrollbar-forward' );
			that.el.$scrollbarBackwardBtn = that.el.$scrollbar.find( '.scroller-scrollbar-backward' );

			_updateDimentions();
			that.element.on( 'update', function() {

				_updateDimentions();
				_updateHandlerPos();

			});

			that.element.on( 'setScrollPos', _updateHandlerPos );

			that.el.$scrollbarHandler.on( 'mousedown', _onHandlerMousedown );

		}

	});

})( jQuery );;

(function( $ ) {

	"use strict";

	function getPageSize() {
		return [
			$( document ).width(),
			$( document ).height(),
			$( window ).width(),
			$( window ).height(),
			$( window ).scrollLeft(),
			$( window ).scrollTop()
		]
	}

	/**
   *  contentScroller
   */
  $.fn.contentScroller = function(settings)
  {
    return this.each(function(){
      settings = $.extend({
        contentQuery: '.content',
        scrollUpBtnQuery: '.sroll_up',
        scrollDownBtnQuery: '.sroll_down',
        scrollUpBtnDisabled: 'sroll_up-disabled',
        scrollDownBtnDisabled: 'sroll_down-disabled',
        scrollEasing: 'linear',
        scrollDuration: 200,
        scrollDir: 'vertical',
        scrollLength: .4
      }, settings);

      var $self          = $(this),
          $content       = $self.find(settings.contentQuery),
          $scrollUpBtn   = $self.find(settings.scrollUpBtnQuery),
          $scrollDownBtn = $self.find(settings.scrollDownBtnQuery);

      var scroll = function(dir) {
        var scrollLength = 0;
        var scrollDiff = 0;

        // stop all animations
        $content.stop();

        if ( settings.scrollDir == 'vertical' ) {

          scrollLength = settings.scrollLength < 1 ? $content.height() * settings.scrollLength : settings.scrollLength;
          scrollDiff = $content.get(0).scrollHeight - $content.get(0).offsetHeight;
          if ( $content.get(0).scrollTop + dir*scrollLength > scrollDiff || scrollDiff == 0 ) {
            $scrollDownBtn.addClass(settings.scrollDownBtnDisabled);
          } else {
            $scrollDownBtn.removeClass(settings.scrollDownBtnDisabled);
          }
          if ( $content.get(0).scrollTop + dir*scrollLength < 0 || scrollDiff == 0 ) {
            $scrollUpBtn.addClass(settings.scrollUpBtnDisabled);
          } else {
            $scrollUpBtn.removeClass(settings.scrollUpBtnDisabled);
          }
          $content.animate({scrollTop: $content.get(0).scrollTop + dir*scrollLength}, settings.scrollDuration, settings.scrollEasing);

        } else {

          scrollLength = settings.scrollLength < 1 ? $content.width() * settings.scrollLength : settings.scrollLength;
          $content.animate({scrollLeft: $content.get(0).scrollLeft + dir*scrollLength}, settings.scrollDuration, settings.scrollEasing);

        }
      }
      // end of scroll function

      $scrollUpBtn.click(function(){
        $content.stop();
        scroll(-1);
        return false;
      });

      $scrollDownBtn.click(function(){
        $content.stop();
        scroll(1);
        return false;
      });

      $content.mousewheel(function(event, delta){
        if (delta > 0) {
					scroll(-1);
        } else if (delta < 0) {
					scroll(1);
        }
        // if we reach the end of content allow to scroll page
        //if ( !$scrollDownBtn.hasClass(settings.scrollDownBtnDisabled) && !$scrollUpBtn.hasClass(settings.scrollUpBtnDisabled)  )
          return false;
      });

    });
  }
	function showHugeImage(_thumbCurrent, $thumbList) {
	    var settings = {
	      overlayApperSpped: 200,
	      panelApperSpead: 100,
	      panelDisapperSpead: 800,
	      panelApperEasing: 'easeInQuad',
	      thumbFadeOutSpeed: 200,
	      thumbFadeInSpeed: 100,
	      thumbFadeOutEasing: 'easeInQuad',
	      thumbFadeInEasing: 'linear',
	      thumbWidth: 43,
	      thumbMargin: 12,
	      moveInterval: 50,
	      moveStep: 3
	    }

	    var $html = $('\
	        <div id="huge_gallery_overlay"><div id="huge_gallery_wrapper">\
	          <div id="huge_gallery_image_viewport"><img src="/img/s.gif" alt="" class="image" style="z-index: 1;" /></div>\
	          <a href="#" id="huge_gallery_prev"></a>\
	          <a href="#" id="huge_gallery_next"></a>\
	          <div id="huge_gallery_panel_top_wrapper"><div id="huge_gallery_panel_top">\
	            <a href="#" id="huge_gallery_back"></a>\
	            <div id="huge_gallery_nav">\
	                <a href="#" id="huge_gallery_nav_prev"></a>\
	                <a href="#" id="huge_gallery_nav_next"></a>\
	            </div>\
	            <a href="#" id="huge_gallery_close"></a>\
	          </div></div>\
	          <div id="huge_gallery_panel_wrapper"><div id="huge_gallery_panel">\
	            <a href="#" id="huge_gallery_control_play"></a>\
	            <span id="huge_gallery_fitscreen" class="fit"></span>\
	            <div id="huge_gallery_control">\
	              <a href="#" class="prev"></a>\
	              <a href="#" class="next"></a>\
	              <div id="huge_gallery_control_viewport_wrapper"><div id="huge_gallery_control_viewport">\
	                <table><tbody><tr>\
	                </tr></tbody></table>\
	              </div></div>\
	            </div>\
	          </div></div>\
	        </div></div>\
	    ');

	    var $wrapper = $html.find('#huge_gallery_wrapper');
	    var $image_viewport = $html.find('#huge_gallery_image_viewport');
	    var $prev = $html.find('#huge_gallery_nav_prev');
	    var $next = $html.find('#huge_gallery_nav_next');
	    var $btnClose = $html.find('#huge_gallery_close');
	    var $back = $html.find('#huge_gallery_back');
	    var $play = $html.find('#huge_gallery_control_play');
	    var $panel = $html.find('#huge_gallery_panel');
	    var $panel_top = $html.find('#huge_gallery_panel_top');
	    var $thumbViewport = $html.find('#huge_gallery_control_viewport');
	    var $thumbContainer = $html.find('#huge_gallery_control_viewport tr');
	    var $btnFitScreen = $html.find( '#huge_gallery_fitscreen' );
	    var preloadedImage = null;
	    var $thumbCurrent = null;
	    var pageSize = null;
	    var timer = null;
	    var cursor = null;
	    var $newImage = $image_viewport.find('.image');
	    var currentScrollTop = 0;
	    var notIEWidnowWidthCorrection = 15;

	    var playerTimer = null;
	    var playerSpeed = 5000;

	    var activityTimer = null;
	    var activityTimeout = 2000;

	    var $currentImage = null;
        var currentImage = null;

	    /*if ( $thumbList.length > 1 ) {
	      $prev.add($next).show();
	    }*/

	    var updatePageSizeInfo = function(){
	      pageSize = getPageSize();
	      $(document.body).css({height: pageSize[3]});
	      $image_viewport.height(pageSize[3] - 110);
	      if ( $btnFitScreen.hasClass( 'fit' ) ) {
	        if ( $currentImage && currentImage ) {
	          fitImage( $currentImage, currentImage );
	        }
	      }
	    }

	    function fitImage( $img, img ){
	      var ratio = Math.min( $image_viewport.width() / img.width, $image_viewport.height() / img.height );
	      if ( ratio < 1 ) {
	        $img
	          .attr( 'width', Math.floor( img.width * ratio ) )
	          .attr( 'height', Math.floor( img.height * ratio ) )
	          .css( {
	            marginTop: - $img.height() / 2,
	            marginLeft: - $img.width() / 2
	          } );
	      }
	    }

	    function unFitImage( $img ){
	      $img
	        .removeAttr( 'width' )
	        .removeAttr( 'height' )
	        .css( {
	          marginTop: - $img.height() / 2,
	          marginLeft: - $img.width() / 2
	        } );
	    }

	    function toggleFit( evt ) {
	      if ( $(this).hasClass('fit') ) {
	        unFitImage($currentImage);
	        $(this).removeClass('fit');
	      } else {
	        fitImage($currentImage, currentImage);
	        $(this).addClass('fit');
	      }
	      return false;
	    }

	    var updateMouseCoords = function(evt){
	      cursor = {
	      	x: evt.pageX,
	      	y: evt.pageY
	      }
	    }

	    var panel_show = function() {
	      $panel.add($panel_top).stop().animate({opacity: 1},  settings.panelApperSpead, settings.panelApperEasing);
	    }

	    var panel_hide = function() {
	      $panel.add($panel_top).stop().animate({opacity: 0}, settings.panelDisapperSpead, settings.panelAppearEasing);
	    }

	    var play = function() {
	      playerTimer = setTimeout(function(){
	        showNext();
	      }, playerSpeed);
	    }

	    var pause = function() {
	      clearInterval(playerTimer);
	    }

	    var switchPlay = function() {
	      if ( $play.hasClass('huge_gallery_control_play_pause') ) {
	        $play.removeClass('huge_gallery_control_play_pause');
	        play();
	      } else {
	        $play.addClass('huge_gallery_control_play_pause');
	        pause();
	      }
	      return false;
	    }

	    $play.click(switchPlay);

	    var close = function() {
	      pause();
	      $html.fadeOut(settings.overlayApperSpped, function(){
	        $html.remove();
	        $(document.body)
	          .css({
	            overflow: 'auto',
	            height: 'auto'
	          });
	        $('html').css('overflow', 'auto');
	        $('html, body').attr('scrollTop', currentScrollTop);
	        //show bottom panel
	        $('#bottom_menu').show();
	      });
	      $(window).unbind('resize', updatePageSizeInfo);
	      $wrapper.unbind('mousemove', updateMouseCoords);
	      $wrapper.unbind('mousemove', panelAutoHide);
	      return false;
	    }

	    var panelAutoHide = function() {
	      clearTimeout(activityTimer);
	      panel_show();
	      activityTimer = setTimeout(function(){
	        panel_hide();
	      }, activityTimeout);
	    }

	    var open = function() {
	      //hide bottom panel
	      $('#bottom_menu').hide();

	      $back.text('\u0412\u0435\u0440\u043d\u0443\u0442\u044c\u0441\u044f \u043a ' + $('h1').text());

	      updatePageSizeInfo();
	      $(window).bind('resize', updatePageSizeInfo);
	      $wrapper.bind('mousemove', updateMouseCoords);
	      $wrapper.bind('mousemove', panelAutoHide);

	      currentScrollTop = Math.max($('body').attr('scrollTop'), $('html').attr('scrollTop'));
	      $('html, body').attr('scrollTop', 0);
	      $('html').css('overflow', 'hidden');
	      $(document.body)
	        .css({
	          overflow: 'hidden',
	          height: pageSize[3]
	        })
	        .append($html);
	      $( document )
	        .keydown(function(e){
	          switch (e.keyCode) {
	            case 27:close();break; //esc
	            case 37:showPrev();break; //arrow left
	            case 39:showNext();break; //arrow right
	            // to avoid scroll down by keybord
	            case 34: //page down
	            case 40:return false;break; //arrow down
	          }
	        });

	      $thumbList.each(function(num){
	        var $image = $(this).find('img');
	        var imageRatio = 43 / Math.min($image.width(), $image.height());
	        var imageSrc = this.href.substr(this.href.indexOf('#') + 1);
	        var $thumb = $('<td><a href="#" _href="' + imageSrc + '" num="' + num + '"><i></i><img src="' + $image.attr('src') + '" width="' + $image.width()*imageRatio + '" height="' + $image.height()*imageRatio + '" alt="" />"</a></td>');
	        $thumb.find('a')
	          .click(function(){thumbClick($(this));return false;})
	          .bind("contextmenu dragstart",function(){return false;});
	        $thumb.appendTo($thumbContainer);
	        if ( this == _thumbCurrent ) {
	          $thumbCurrent = $thumb.find('a');
	          thumbClick($thumbCurrent);
	        }
	      });

	      //thumbClick($thumbCurrent.find('a'));

	      $html.fadeIn(settings.overlayApperSpped, function(){
	        panel_show();
	      });

	      panelAutoHide();

	      $html.contentScroller({
	        contentQuery: '#huge_gallery_control_viewport',
	        scrollUpBtnQuery: '#huge_gallery_control .prev',
	        scrollDownBtnQuery: '#huge_gallery_control .next',
	        scrollDir: 'horizontal',
	        scrollEasing: 'linear',
	        scrollDuration: 200,
	        scrollLength: .3
	      })

	    }

	    var onLoad = function($thumb) {
	      var $oldImage = $image_viewport.find('.image');
	      var $newImage = $('<img src="' + $thumb.attr('_href') + '" class="image" />');
	      $newImage.bind("contextmenu mousedown dragstart",function(){
	        return false;
	      });
	      $currentImage = $newImage;
	      currentImage = preloadedImage;
	      $oldImage.fadeOut(function(){
	        $(this).remove();
	      });
	      if ( $btnFitScreen.hasClass( 'fit' ) ) {
	        fitImage( $newImage, preloadedImage );
	      }
	      $newImage
	        .hide()
	        .css({
	          marginTop: - ( parseInt( $btnFitScreen.hasClass('fit') ? $newImage.attr( 'height' ) || preloadedImage.height : preloadedImage.height ) ) / 2,
	          marginLeft: - ( parseInt( $btnFitScreen.hasClass('fit') ? $newImage.attr( 'width' ) || preloadedImage.width : preloadedImage.width ) ) / 2
	        })
	        .appendTo($image_viewport);
	      if ( timer ) {
		      clearInterval(timer);
	      }
	      timer = setInterval(function(){
	        var imageExceedHeight = $image_viewport.height() - $newImage.height(),
	            imageExceedWidth = $image_viewport.width() - $newImage.width();

	        if ( cursor === null ) {
	          return;
	        }

	        $newImage
	          .css( {
	            marginTop: imageExceedHeight >= 0 ? imageExceedHeight / 2 - $image_viewport.height() / 2 : parseInt( $newImage.css( 'marginTop' ) ) * ( 1 - 1 / settings.moveStep ) + ( ( - $image_viewport.height() / 2 + ( imageExceedHeight * Math.min( cursor.y, $image_viewport.height() ) / $image_viewport.height() ) ) ) / settings.moveStep,
	            marginLeft: imageExceedWidth >= 0 ? imageExceedWidth / 2 - $image_viewport.width() / 2 : parseInt( $newImage.css( 'marginLeft' ) ) * ( 1 - 1 / settings.moveStep ) + ( ( - $image_viewport.width() / 2 + ( imageExceedWidth * Math.min( cursor.x, $image_viewport.width() ) / $image_viewport.width() ) ) ) / settings.moveStep
	          } );
	      }, settings.moveInterval);

	      $newImage.fadeIn();
	      if ( !$play.hasClass('huge_gallery_control_play_pause') )
	        play();
	    }

	    var thumbClick = function($thumb) {
	      if ( $thumb.hasClass('opened') ) return false;
	      if ( $thumb.attr('num') == 0 )
	        $prev.hide();
	      else
	        $prev.show();
	      if ( $thumb.attr('num') == $thumbList.length - 1 )
	        $next.hide();
	      else
	        $next.show();
	      $thumbCurrent.removeClass('opened');
	      var $loader = $thumb.find('i');
	      // abort onload event if image is already loading
	      if ( preloadedImage != null ) {
	        preloadedImage.onload = null;
	        $thumbCurrent.removeClass('loading');
	      }
	      $thumbCurrent = $thumb;
	      //center thumbs list as possible
	      /*if ( $thumbContainer.width() - $thumbViewport.width() > 0 ) {
	        if ( $thumbCurrent.attr('num') <= 3 )
	          $thumbViewport.stop().animate({scrollLeft: 0});
	        else if ( $thumbContainer.find('td').length - $thumbCurrent.attr('num') <= 4 )
	          $thumbViewport.stop().animate({scrollLeft: $thumbContainer.width() - $thumbViewport.width() - settings.thumbMargin});
	        else
	          $thumbViewport.stop().animate({scrollLeft: ( settings.thumbWidth + settings.thumbMargin ) * ( $thumbCurrent.attr('num') - 3 )});
	      }*/

	      pause();
	      //load a huge image
	      preloadedImage = new Image();
	      preloadedImage.onload = function() {
	          $thumb.removeClass('loading').addClass('opened');
	          onLoad($thumb);
	          preloadedImage.onload = null; /* not sure it's necessary because of the next line */
	          preloadedImage = null;
	      };
	      preloadedImage.src = $thumb.attr('_href');
	      if ( preloadedImage != null )
	          $thumb.addClass('loading');
	      return false;
	    }

	    var showNext = function() {
	      if ( $thumbCurrent.parents('td:first').next().length > 0 )
	        thumbClick($thumbCurrent.parents('td:first').next().find('a'));
	      else
	        thumbClick($thumbContainer.find('td:first a'));
	      return false;
	    }

	    var showPrev = function() {
	      if ( $thumbCurrent.parents('td:first').prev().length > 0 )
	        thumbClick($thumbCurrent.parents('td:first').prev().find('a'));
	      else
	        thumbClick($thumbContainer.find('td:last a'));
	      return false;
	    }

	    /*$next.click(function(){
	      if ( !$play.hasClass('huge_gallery_control_play_pause') )
	        pause();
	      showNext();
	      if ( !$play.hasClass('huge_gallery_control_play_pause') )
	        play();
	    });
	    $prev.click(function(){
	      if ( !$play.hasClass('huge_gallery_control_play_pause') )
	        pause();
	      showPrev();
	      if ( !$play.hasClass('huge_gallery_control_play_pause') )
	        play();
	    });*/
		$btnFitScreen.click( toggleFit );
	    $next.click(showNext);
	    $prev.click(showPrev);
	    $btnClose.add($back).click(close);

	    open();

  	};

	$.widget( 'mm.slideshow', {

		options: {
			viewport:      '.slideshow-viewport',
			btnPrev:       '.slideshow-prev',
			btnNext:       '.slideshow-next',
			thumb:         '.slideshow-preview',
			currentThumbClass:  'slideshow-preview--current',
			zoomClass: 	   'slideshow-viewport--zoom',
			zoomBtn: 	   '.slideshow-zoom_in',
			slide:         '.slideshow-slide',
			swapDuration:  200,
			swapEasing:    'linear',
			slideTpl: 		'<div class="slideshow-slide"></div>',
			autoplay: 0
		},

		_create: function() {

			var that = this,

				$cont = $( that.element ),
				$viewport = $cont.find( that.options.viewport ),
				$btnPrev = $cont.find( that.options.btnPrev ),
				$btnNext = $cont.find( that.options.btnNext ),
				$thumbs = $cont.find(  that.options.thumb ),
				$zoomBtn = $cont.find( that.options.zoomBtn ),
				$scroller = $cont.find( '.slideshow-previews' ),
				$newSlide = $( 'nothing' ),
				$zoomThumb;

			$scroller.scroller({
				scrollPage: true,
				mouseDisable: true
			});

			updateZoom( $thumbs.filter( '.slideshow-preview--current' ) );

			$viewport.on( 'click', runGallery );

			function runGallery() {
				if ( $viewport.hasClass( that.options.zoomClass ) ) {
					showHugeImage( $zoomThumb.get(0), $thumbs.filter(function() {

						var hash = this.href.indexOf('#');

						return (hash > 0 && this.href.substr( hash + 1 ).length > 0);

					}) );
				}
			}

			function updateZoom( $thumb ) {

				var hash = $thumb.attr( 'href' ).indexOf('#');

				if ( hash > 0 && $thumb.attr( 'href' ).substr( hash + 1 ).length > 0 ) {
					$zoomThumb = $thumb;
					$zoomBtn.show();
					$viewport.addClass( that.options.zoomClass )
				} else {
					$zoomBtn.hide();
					$viewport.removeClass( that.options.zoomClass );
				}

			}

			function showImage( $thumb ) {

				var $oldSlides = $viewport.find( that.options.slide );

				$thumbs.removeClass( that.options.currentThumbClass );
				$thumb.addClass( that.options.currentThumbClass );

				$scroller.scroller( 'centerTo', $thumb );

				// fix viewport height
				$viewport.height( $oldSlides.last().height() );

				$oldSlides.not(':animated').css({
					opacity: 1,  // set explicitly for ie
					position: 'absolute',
					'z-index': 2
				});

				if ( $newSlide.length > 0 && !$newSlide.data( 'isLoaded' ) ) {
					$newSlide.off( 'load' ).remove();
				}

				$newSlide = $( that.options.slideTpl )
					.append( "<img src='" +  $thumb.attr( 'href' ) + "'/>" )
					.css({
						opacity: 1,  // set explicitly for ie
						position: 'absolute',
						'z-index': 1
					}).appendTo( $viewport );

				$newSlide.children( 'img' ).on( 'load', function() {

					$newSlide.data( 'isLoaded', true );

					updateZoom( $thumb );

					$oldSlides.not( ':animated' ).animate( { opacity: 0 }, that.options.swapDuration, that.options.swapEasing, function() {

						$( this ).remove();

					});

					if ( $viewport.height() !== $newSlide.height() ) {
						$viewport.animate( { height: $newSlide.height() }, that.options.swapDuration );
					}

				});

			}

			$btnPrev.on( 'click', function( evt ) {

				var $prevThumb = $thumbs.filter( '.' + that.options.currentThumbClass ).prev( that.options.thumb );

				if ( $prevThumb.length < 1 ) {
					$prevThumb = $thumbs.last();
				}

				showImage( $prevThumb );

			});

			$btnNext.on( 'click', function( evt ) {

				var $nextThumb = $thumbs.filter( '.' + that.options.currentThumbClass ).next( that.options.thumb );

				if ( $nextThumb.length < 1 ) {
					$nextThumb = $thumbs.first();
				}

				showImage( $nextThumb );

			});

			$thumbs.on( 'click', function( evt ) {

				evt.preventDefault();

				if ( !$( this ).hasClass( that.options.currentThumbClass ) ) {
					showImage( $( this ) );
				}

			});

		}

	});

})( jQuery );;
(function( $, window ){

	"use strict";

	// Mark touch device for css styles
	( "ontouchstart" in window || window.DocumentTouch && document instanceof DocumentTouch ) && $( 'html' ).removeClass( 'no-touch' );

	// Enable live reload for dev enviroment (with port number defined)
	if ( location.host.indexOf( ':' ) >= 0  && ( ( "WebSocket" in window ) || ( "MozWebSocket" in window ) ) ) {
		$( '<script src="http://' + location.host.split(':')[0] + ':35729/livereload.js"></script>' ).appendTo( $( 'body' ) );
	}

	function initAll( context ) {

		$( '.popup-inner-file', context ).each(function() {
			var $decor = $(this),
				$source = $decor.find( '.popup-inner-file-source' );

			$source.on( 'change', function() {
				$decor.addClass( 'popup-inner-file--check' );

			});

		});

		/*
			Slideshow
		 */
		$( '.slideshow', context ).slideshow();

		/*
			Form validation and placeholders polyfill
		 */
		H5F.setup( $( 'form', context ).toArray(), {
			invalidClass: 'invalid'
		});

		/*
			How we work
		 */
		$( '.how_work', context ).each(function() {
			var options = {
					titleSelectedClass: 'how_work-selected',
					contentSelectedClass: 'how_work-list--selected'
				},
				$container = $( this ),
				$titles = $container.find( '.how_work-center > span' ),
				$contents = $container.find( '.how_work-list' );

			$titles.each(function( index ) {
				var $title = $( this ),
					$content = $contents.eq( index );

				$title.on( 'click', function() {
					if ( $( this ).hasClass( options.titleSelectedClass ) ) {
						return;
					}

					$titles.removeClass( options.titleSelectedClass );
					$title.addClass( options.titleSelectedClass );
					$contents.removeClass( options.contentSelectedClass );
					$content.addClass( options.contentSelectedClass );
				});
			});
		});

		/*
			Page down button
		 */
		$( '.page_down', context ).each(function() {
			var options = {
					scrollDuration: 500,
					scrollEasing: 'easeOutQuint',
					scrollTo: 167, // .header height
					btnAnimateDuration: 300,
					btnHeight: 19
				},
				$btn = $( this ),
				$window = $( window ),
				isHidden = false;

			$window.on( 'scroll', function() {
				if ( isHidden && $window.scrollTop() === 0 ) {
					isHidden = false;
					$btn.stop().animate({ bottom: 0 }, options.btnAnimateDuration );
				}
				if ( !isHidden && $window.scrollTop() !== 0 ) {
					isHidden = true;
					$btn.stop().animate({ bottom: -options.btnHeight	 }, options.btnAnimateDuration );
				}
			});

			$btn.on( 'click', function() {
				$( 'html, body' ).animate({ scrollTop: options.scrollTo }, options.scrollDuration, options.scrollEasing );
			});
		});

		/*
			Page up button
		 */
		$( '.page_up', context ).each(function() {
			var options = {
					scrollDuration: 500,
					scrollEasing: 'easeOutQuint',
					btnAnimateDuration: 300,
					btnBottom: 46,
					btnBottomHide: 20
				},
				$btn = $( this ),
				$window = $( window ),
				isHidden = true;

			$window.on( 'scroll', function() {
				if ( isHidden && $window.scrollTop() !== 0 ) {
					isHidden = false;
					$btn
						.css({
							display: 'block',
							opacity: 0
						})
						.stop().animate({ bottom: options.btnBottom, opacity: 1 }, options.btnAnimateDuration );
				}
				if ( !isHidden && $window.scrollTop() === 0 ) {
					isHidden = true;
					$btn.stop().animate({ bottom: options.btnBottomHide, opacity: 0 }, options.btnAnimateDuration, function() {
						$btn.css( 'display', 'none' );
					});
				}
			});

			$btn.on( 'click', function() {
				$( 'html, body' ).animate({ scrollTop: 0 }, options.scrollDuration, options.scrollEasing );
			});
		});

		/*
			Header slim and Aside
		 */
		$( '.header', context ).each(function() {
			var options = {
					headerFixedClass: 'header--fixed',
					asideFixedClass: 'aside--fixed',
					fixTop: 103,
					animateDuration: 300
				},
				$header = $( this ),
				$slim = $header.find( '.header_slim' ),
				$aside = $( '.aside' ),
				$window = $( window ),
				isFixed = false,
				windowHeight,
				windowScrollDiff;

			function updateDimensions() {
				windowHeight = $window.height();
				windowScrollDiff = Math.max( $( 'html' ).height(), $( 'body' ).height() ) - windowHeight;
			}

			function update() {
				var scrollTop = $window.scrollTop();

				if ( isFixed ) {
					if ( scrollTop < options.fixTop ) {
						isFixed = false;
						$header.removeClass( options.headerFixedClass );
						$aside.removeClass( options.asideFixedClass );
						$slim.css( 'display', 'none' );
					} else {
						if ( scrollTop > windowScrollDiff - 28 ) {
							$aside.css( 'height', windowHeight - ( scrollTop - windowScrollDiff + 28 ) );
						} else {
							$aside.css( 'height', windowHeight );
						}
					}
				}
				if ( !isFixed ) {
					if ( scrollTop >= options.fixTop ) {
						isFixed = true;
						$header.addClass( options.headerFixedClass );
						$aside.addClass( options.asideFixedClass );
						$slim.css({
							display: 'block',
							opacity: 0
						});
						$slim.stop().animate({ opacity: 1 }, options.animateDuration );

						$aside.css( 'height', windowHeight );
					} else {
						$aside.css( 'height', windowHeight + scrollTop );
					}
				}
			}

			$window.on( 'resize', updateDimensions );
			updateDimensions();
			$window.on( 'resize', update );
			$window.on( 'scroll', update );
			update();
		});

		/*
			Sec menu submenu
		 */
		$( '.sec_menu', context ).each(function() {
			var $secMenu = $( this ),
				$submenus = $secMenu.find( '.smenu' );

			$submenus.each(function() {
				var options = {
						itemHoverClass: 'sec_menu-hover'
					},

					$submenu = $( this ),
					$item = $submenu.parent( 'div' ),
					$itemBefore = $item.prev( 'b' ),
					$itemBeforePlace = $itemBefore.children( 'b' ),
					$itemAfter = $item.next( 'b' ),
					$itemAll = $item.add( $itemBefore ).add( $itemAfter ),

					itemBeforeWidth,
					itemAfterWidth,
					itemWidth,
					hideTimer,

					supportTouch = !!( "ontouchstart" in window || window.DocumentTouch && document instanceof DocumentTouch );

				function updateDimensions() {
					itemBeforeWidth = $itemBefore.width();
					itemAfterWidth = $itemAfter.width();
					itemWidth = $item.width();
				}

				function show() {
					hideTimer && clearTimeout( hideTimer );
					$submenu.css({
						display: 'block',
						minWidth: itemBeforeWidth + itemWidth + itemAfterWidth
					});
					$itemAll.addClass( options.itemHoverClass );
				}

				function hide() {
					$submenu.css( 'display', 'none' );
					$itemAll.removeClass( options.itemHoverClass );
				}

				function closeOnTouchOutside() {
					$( document.body ).unbind( 'click', closeOnTouchOutside );

					// give time to catch click on submenu
					setTimeout( hide, 1 );
				}

				$itemAll.on( 'mouseover', show );

				$itemAll.on( 'mouseout', function() {
					hideTimer = setTimeout( hide, 1 );
				});

				// for touch devices show submenu on touch
				if ( supportTouch ) {
					$itemAll.bind( 'click', function( evt ) {
						// if not is opened, prevent following link and show submenu
						if ( !$item.hasClass( options.itemHoverClass ) ) {
							evt.preventDefault();

							setTimeout(function() {
								$( document.body ).bind( 'click', closeOnTouchOutside );
							}, 1 );
							show();
						}
					});
				}

				$( window ).on( 'load', updateDimensions );
				updateDimensions();

				$submenu.appendTo( $itemBeforePlace );
			});
		});

		/*
			UICheckboxes
		 */
		$( 'input[type="checkbox"]', context ).UICheckbox();

		/*
			Match set
		 */
		$( '.match-set', context ).each(function() {
			var options = {
					collapsedClass: 'match-set--collapsed'
				},
				$set = $( this ),
				$title = $set.find( '.match-set-title' );

			$title.on( 'click', function() {
				$set.toggleClass( options.collapsedClass );
			});
		});

		/*
			Inplace
		 */
		$( '.inplace', context ).each(function() {

			var $inplace = $( this ),
				data = $inplace.data( 'inplace' ),
				zIndex = 1;

			$.each( data.items, function() {

				var $plus = $( '<div class="inplace-plus"></div>' ),
					$data = $( '#inplace_' + this.id ),
					data_width = parseInt( $data.css( 'width' ), 10 ),
					data_height = parseInt( $data.css( 'height' ), 10 ),
					x = this.x * data.image_size.width,
					y = this.y * data.image_size.height;

				if ( $data.length < 1 ) {
					$plus.hide();
				}

				if ( this.x < 0.5 && this.y < 0.5 ) {
					$data.css({
						left: x,
						top: y
					});
				} else if ( this.x >= 0.5 && this.y < 0.5 ) {
					$data.css({
						left: x - data_width,
						top: y
					});
				} else if ( this.x < 0.5 && this.y >= 0.5 ) {
					$data.css({
						left: x,
						top: y - data_height
					});
				} else if ( this.x >= 0.5 && this.y >= 0.5 ) {
					$data.css({
						left: x - data_width,
						top: y - data_height
					});
				}

				$plus.on( 'click', function() {

					if ( $data.is( ':visible' ) ) {
						return ;
					}

					$data.css( 'zIndex', zIndex++ );
					$data.fadeIn( 300 );

				});

				$data.on( 'click', function() {

					// move $data up
					$data.css( 'zIndex', zIndex++ );

				});

				$data.find( '.inplace-item-close' ).on( 'click', function() {

					$data.fadeOut( 300 );

				});

				$plus.css({
					left: x,
					top: y
				});

				$plus.appendTo( $inplace );

			});

		});

		/*
			Service
		 */
		$( '.service' ).each(function() {
			var options = {
					slideCurrentClass: 'service-slide--current',
					linkCurrentClass: 'pagination-link--current'
				},
				$service = $( this ),
				$slides = $service.find( '.service-slide' ),
				$links = $service.find( '.pagination .pagination-link' ),
				$btnBackward = $service.find( '.service-btn--backward' ),
				$btnForward = $service.find( '.service-btn--forward' ),
				currentSlide = 0,
				countSlides = $links.length;

			function slideInDir( dir ) {
				if ( dir === '>' ) {
					currentSlide++;
					currentSlide = currentSlide >= countSlides ? 0 : currentSlide;
					$links.eq( currentSlide ).trigger( 'click' );
				} else if ( dir === '<' ) {
					currentSlide--;
					currentSlide = currentSlide < 0 ? countSlides - 1 : currentSlide;
					$links.eq( currentSlide ).trigger( 'click' );
				}
			}

			$links.each(function( index ) {
				var $link = $( this ),
					$slide = $slides.eq( index );

				if ( $link.hasClass( options.linkCurrentClass ) ) {
					currentSlide = index;
				}

				$link.on( 'click', function() {
					$slides.removeClass( options.slideCurrentClass );
					$slide.addClass( options.slideCurrentClass );
					$links.removeClass( options.linkCurrentClass );
					$link.addClass( options.linkCurrentClass );
				});
			});

			$btnBackward.on( 'click', function() {
				slideInDir( '<' );
			});

			$btnForward.on( 'click', function() {
				slideInDir( '>' );
			});
		});

		/*
			Shopping cart remove item
		 */
		$( '.fav-item .button_grey--del' ).each(function() {
			var $btnDel = $( this ),
				$item = $btnDel.parents( '.fav-item:first' );

			$btnDel.on( 'click', function( evt ) {

				evt.preventDefault();

				$.ajax({
					url: $btnDel.data( 'ajax' ).url
				});

				$item.slideUp( 200, function() {

					$item.remove();

				});

			});
		});
	}

	/*
	 *   DOM Ready section
	 */
	$(function(){

		// Remove click delay on touch devices
		FastClick.attach( document.body );

		initAll( document.body );

	});
	// End of DOM ready section

})( jQuery, window );